<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-28T01:47:17+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">悲催的袜子</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">为LLVM添加简易RISCV后端(五)：算术指令</title><link href="http://localhost:4000/blog/RISCW-5.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(五)：算术指令" /><published>2020-12-11T11:30:38+08:00</published><updated>2020-12-11T11:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-5</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-5.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;算术指令&quot;&gt;算术指令&lt;/h2&gt;

&lt;p&gt;现在，我们将把上一篇文章讨论的关于LLVM后端中的指令选择付诸实践。
我们将通过查看RISCW后端的算术指令(比如加法、减法和乘法)的具体实现来做到这一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这篇文章中讨论的代码可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/commit/38ac00579c9e84cb4374d34da917a37142f072ca&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;p&gt;RISCW的算术指令相对简单，
在指令选择过程中仅需要配置指令选择器和合法化器，这主要需编写三部分代码。
首先，使用TableGen描述目标平台支持的指令集。
其次，通知LLVM需要合法化的算术运算和类型。
最后，添加自定义C++代码来增强指令选择器的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在为不同体系结构实现指令选择时，总体思路大致相似，但是具体情况将有所不同。
例如，您的指令集可能具有有趣的/复杂的算术指令，例如长乘或多次累加，可能需要额外的代码来正确地支持这些指令。
另外，我们不会自定义优化，但是您可以查看其他后端有关自定义优化的内容，例如XCore和ARM有很多很好的例子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里显示的大部分代码最初来自LLVM现有的RISCV后端，但是为了照顾本教程的读者，它已经被大大简化了。&lt;/p&gt;

&lt;h3 id=&quot;tablegen&quot;&gt;TableGen&lt;/h3&gt;

&lt;p&gt;TableGen是描述体系结构（包括寄存器，指令集，调用约定等）的专用编程语言，
其目标是创建可维护、易于阅读的代码来描述体系结构。
在构建LLVM时，TableGen工具将TableGen代码翻译为C++并将其与手工编码的C++文件一起编译。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;实际上，我发现TableGen代码很难阅读，更难编码！&lt;/p&gt;

&lt;p&gt;简而言之，TableGen是具有以下功能的声明性编程语言：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;有两个主要组件： &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;的实例，包含了名称和相关字段的值。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;的抽象，可用于生成具体的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;。
两者相互配合可以很好地提取公共代码并减少重复。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;可以从一个或多个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;继承，还可以定义自己的字段。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字段具有名称和值（或值列表），值具有特定的类型（如bit或int）。&lt;a href=&quot;https://llvm.org/docs/TableGen/ProgRef.html#types&quot;&gt;这是&lt;/a&gt;类型列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include&lt;/code&gt;指令用于将TableGen代码从一个文件包含到另一个文件中，就像C的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#include&lt;/code&gt;一样。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是从LLVM&lt;a href=&quot;https://llvm.org/docs/TableGen/ProgRef.html#examples-classes-and-records&quot;&gt;文档&lt;/a&gt;中获取的示例，其中显示了一个非常简单的TableGen文件。
它包含一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;C，该&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt;定义了值为1的bit类型的字段V，
还声明了一个从类C派生的记录X。&lt;/p&gt;

&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;bit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;X :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;后端需要定义TableGen的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;，用以声明指令、寄存器等。
这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;必须从内部类继承，这样TableGen工具才能魔术地为这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;生成适当的C++代码。
例如，声明寄存器的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;必须从内部的Register类继承。
在这篇文章中，我们将查看声明寄存器和指令的TableGen代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;TableGen文档在解释它是什么和语法方面做得很好。
但是，介绍后端应该重用的内部类和预定义记录的文档却很少；要了解这些内容您必须查看源代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;回想一下之前的文章，
我们的CMake文件使用带各种参数的TableGen命令把扩展名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.td&lt;/code&gt;的TableGen代码文件转化为扩展名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.inc&lt;/code&gt;的C++文件。
在构建系统发出TableGen命令之后，可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build/lib/Target/RISCW&lt;/code&gt;的构建目录中找到生成的文件。
Tablegen的参数可以&lt;a href=&quot;https://llvm.org/docs/CommandGuide/tblgen.html&quot;&gt;这里&lt;/a&gt;(非常简短地)查看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;TableGen还可以配置指令选择过程中的调度和形成阶段，但是我不会在本教程中讨论这一点。
如果你感兴趣，可以看看&lt;a href=&quot;https://www.youtube.com/watch?v=brpomKUynEA&amp;amp;ab_channel=LLVM&quot;&gt;这个视频&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;定义寄存器&quot;&gt;定义寄存器&lt;/h3&gt;
&lt;p&gt;RISCW的寄存器定义非常简单，
可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/RISCWRegisterInfo.td&lt;/code&gt;中找到。 
让我们对其进行剖析，以了解TableGen的工作方式。&lt;/p&gt;

&lt;p&gt;在文件的顶部，我们找到以下类。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Namespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;RISCW&quot;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWReg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Enc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;alt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;HWEncoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4-0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Enc&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;AltNames&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;alt&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Namespace&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该代码声明了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWReg&lt;/code&gt;类，该类继承自在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include/llvm/Target/Target.td&lt;/code&gt;中定义的内部类Register。
该代码还告诉我们，从此类继承时，我们必须提供最多三个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;寄存器编码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enc&lt;/code&gt;，它是类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bits&amp;lt;5&amp;gt;&lt;/code&gt;的5位整数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字符串&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;，表示人类可读的寄存器名称，如RISCV中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x0&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x1&lt;/code&gt;等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寄存器的别名列表，该列表是可选的。
例如，RISCV中的x2也可以称为sp，即堆栈指针。
但请注意，此列表是可选的，因为可以声明没有别名的寄存器，如果寄存器没有别名，则把&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt&lt;/code&gt;设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，请注意Register类接受一个参数：类型为字符串的寄存器名称。
RISCWReg的其余两个参数（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enc&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alt&lt;/code&gt;）被&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;let&lt;/code&gt;语句用于覆盖Register类定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HWEncoding&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AltNames&lt;/code&gt;域。
您可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/38ac00579c9e84cb4374d34da917a37142f072ca/llvm/include/llvm/Target/Target.td#L180&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/38ac00579c9e84cb4374d34da917a37142f072ca/llvm/include/llvm/Target/Target.td#L136&quot;&gt;这里&lt;/a&gt;阅读Register的代码。&lt;/p&gt;

&lt;p&gt;接下来，我们在该文件中找到以下Register定义。
每一行代码都是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;，它定义了一个寄存器。
这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;继承自两个类:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWReg&lt;/code&gt;(我们已经讨论过了)和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DwarfRegNum&lt;/code&gt;。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DwarfRegNum&lt;/code&gt;是这里定义的另一个内部类，用于为GCC和GDB提供调试信息。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;X0  :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWReg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;x0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;DwarfRegNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;X31 :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWReg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x31&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;t6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;DwarfRegNum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;文件的最后几行定义寄存器组，
RISCW定义了两种寄存器组：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPR&lt;/code&gt;通用寄存器和堆栈指针&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SP&lt;/code&gt;寄存器。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RegisterClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RISCW&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;sequence&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;X%u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;SP :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RegisterClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RISCW&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;X2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;定义Register组的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;继承自RegisterClass类，后者具有四个参数（还有一个可选的第五个参数，我们将不讨论）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命名空间在我们的例子中是RISCW，这与我们在上面的RISCWReg类中重写的名称空间字段相匹配。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;此组寄存器支持的数据类型列表。
这是一个列表，因为某些体系结构中的寄存器可以支持多种数据类型。
例如，一些64位计算机的寄存器可以在32位和64位模式下工作。
RISCW只适用于32位机器，因此寄存器总是32位，它们的类型就是i32。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从内存中存储或加载寄存器时寄存器的对齐方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个DAG，指示此寄存器组包含的寄存器。还有…&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;我是说DAG！注意，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPR&lt;/code&gt;的DAG有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;模式，该模式有6个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sequence&lt;/code&gt;节点。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sequence&lt;/code&gt;是一种操作，它接受字符串格式参数以及起始值和结束值。
  序列中的每个元素都是TableGen工具根据格式参数指定的格式生成。
  所以，这个DAG的另一种写法是(add X10, X17,…, X3, X4)。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;此DAG还指定了寄存器分配器使用寄存器的顺序。
  例如，如果两者都可用，分配器将优先使用来自GPR的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x10&lt;/code&gt;而不是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x4&lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;寄存器组稍后用于配置合法化器。&lt;/p&gt;

&lt;h3 id=&quot;定义指令&quot;&gt;定义指令&lt;/h3&gt;

&lt;p&gt;计算机体系结构使用一组格式对指令进行编码。
例如，RISCV体系结构使用32位编码和4种基本指令格式来编码指令&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。
此外，每种格式都有一组唯一的操作码(或操作码)。
然后使用格式和操作码对特定指令进行编码，这使处理器能够识别指令并确定它们的操作数。&lt;/p&gt;

&lt;p&gt;在LLVM中，定义指令的方式与定义指令集编码的方式类似。
定义指令的代码通常由两部分组成: 格式定义和指令定义。&lt;/p&gt;

&lt;h4 id=&quot;定义格式&quot;&gt;定义格式&lt;/h4&gt;

&lt;p&gt;定义格式的同时也定义了唯一的标识符，
这些标识符指示指令的格式，
C++代码使用它来正确地发出指令编码。
RISCW后端定义格式的代码，如下所示:&lt;/p&gt;

&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;InstFormatPseudo :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;InstFormatR      :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;InstFormatOther  :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
在LLVM后端中，定义指令格式的代码通常在文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrFormats.td&lt;/code&gt;中，
而实际定义指令的代码在文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrInfo.td&lt;/code&gt;中。
但是在复杂的后端中，
指令定义可以拆分为多个文件，
例如，RISCV的每个扩展都对应一个不同的文件。 
这些文件称为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCV/RISCVInstrInfo&amp;lt;EXT&amp;gt;.td&lt;/code&gt;，
其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;EXT&amp;gt;&lt;/code&gt;是扩展字母，如M，A等。
RISCW后端相对简单，
用于定义格式和指令的TableGen代码分别存储在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/RISCWInstrFormats.td&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCWInstrInfo.td&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;RISCW后端基于RISCV后端。
两者都试图严格地根据RISCV的参考手册定义指令，
但这不是必须的。
你也可以针对你的体系结构和编译器构造只属于你的TableGen代码。&lt;/p&gt;

&lt;p&gt;RISCW后端为操作码定义了如下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWOpcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;OPC_LOAD      :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWOpcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b0000011&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;OPC_LOAD_FP   :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWOpcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b0000111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;OPC_SYSTEM    :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWOpcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b1110011&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所有指令必须继承自LLVM内部的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;类。
方便起见，RISCW后端还定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;的子类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWInst&lt;/code&gt;，
它覆盖了许多字段，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Size&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TSFlags&lt;/code&gt;，同时添加了额外的字段。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;类实际上非常庞大，
需要配置许多选项，
我建议您通读LLVM的源代码以了解什么样的配置可以满足你的需求。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;argstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
             &lt;span class=&quot;err&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormat&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Instruction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;SoftFail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;TSFlags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4-0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;类中的许多字段仅对特定任务有用。
例如，仅当发出目标代码时才使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inst&lt;/code&gt;字段和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opcode&lt;/code&gt;。
因此，不要理会您不需要的东西！&lt;/p&gt;

&lt;p&gt;再次为方便起见，
RISCW后端为每种格式定义了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RWInst&lt;/code&gt;类的子类。
我们实际的指令将继承这些“低级的”格式，以避免代码重复。&lt;/p&gt;

&lt;p&gt;格式类根据相关格式的编码覆盖&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Inst&lt;/code&gt;字段的值。
另外，还有一个特殊的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pseudo&lt;/code&gt;类，用于设置&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;类中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isPseudo&lt;/code&gt;字段。
这些pseudo指令通常是栈调整和函数返回等操作的占位符，
我们将在后面的文章中进行探讨。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Pseudo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
             &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;argstr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;argstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormatPseudo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;Sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;isPseudo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;isCodeGenOnly&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInstR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWOpcode&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;err&quot;&gt;dag&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;argstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;argstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;InstFormatR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;rs2&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;rs1&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;rd&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;31-25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct7&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Opcode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关于这些TableGen类，有几点需要强调：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;funct *&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opcode&lt;/code&gt;参数用于形成唯一的操作码，该操作码用于将指令编码为二进制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;outs&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ins&lt;/code&gt;参数是DAG，分别指定指令的输出和输入操作数。 
操作数通常是寄存器或立即数，但也可以是堆栈帧位置，全局地址等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;opcodestr&lt;/code&gt;是指令的助记符，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;用于加法，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SUB&lt;/code&gt;用于减法，等等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argstr&lt;/code&gt;参数是一种格式字符串，用于告诉LLVM如何在汇编中打印指令的操作数。
例如，如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;outs&lt;/code&gt;参数说有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$r1&lt;/code&gt;寄存器操作数，
而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ins&lt;/code&gt;参数说有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$r2&lt;/code&gt;寄存器操作数并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argstr&lt;/code&gt;的格式为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;$r1,$r2&quot;&lt;/code&gt;，
则该指令的汇编将首先显示输出操作数（即紧随助记符之后）然后显示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;,&lt;/code&gt;，然后显示输入操作数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pseudo&lt;/code&gt;中，还有一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pattern&lt;/code&gt;操作数，
它告诉LLVM在目标指令选择阶段可以用该指令替换DAG中的哪些节点。 
更详细的细节以后再讨论！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;定义指令-1&quot;&gt;定义指令&lt;/h4&gt;

&lt;p&gt;为了方便起见，还定义了另一个类，
该类可以根据操作数以及操作是否涉及ALU、内存等来简化指令的定义。
例如，我们有下面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU_rr&lt;/code&gt;类来定义使用ALU（算数逻辑单元）的指令，
该类有三个GPR类型的操作数:两个是输入，一个是输出。
显然，所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU_rr&lt;/code&gt;指令都是R格式的，因为该类继承自 RWInstR。
另外，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU_rr&lt;/code&gt;的定义位于let块中，
它覆盖了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instruction&lt;/code&gt;中值为0的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hasSideEffects&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mayLoad&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mayStore&lt;/code&gt;字段；
这些字段中的大多数都是不言自明的，不过我鼓励您阅读代码以获得更多信息。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;hasSideEffects&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayStore&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ALU_rr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInstR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;funct7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OPC_OP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
              &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$rd, $rs1, $rs2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU_rr&lt;/code&gt;类来定义指令实际上非常简单。
例如，以下是定义&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;指令的代码：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ADD :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ALU_rr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b0000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;WriteIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ReadIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ReadIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TableGen代码很难理解，因为大多数后端都使用深层继承来减少代码重复。
您可能需要拿出笔和纸来手动展开一些记录，以了解其工作原理。
例如，展开&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;的第一级看起来如下所示。
这个较长版本的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;也是有效的TableGen代码，
将以前版本的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;替换为这个较长的版本，
LLVM仍然可以毫无问题地构建！&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;hasSideEffects&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayStore&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;ADD :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInstR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b0000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;b000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OPC_OP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
              &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$rd, $rs1, $rs2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
          &lt;span class=&quot;err&quot;&gt;Sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;WriteIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ReadIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ReadIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;定义带有立即数(而不是寄存器)的指令的方法大致相同，
但必须调整输入操作数。
例如，下面显示的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU_ri&lt;/code&gt;类的第二个输入是名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$imm12&lt;/code&gt;的12位立即数(类型为simm12)。
simm12的定义证实该类的类型为i32还指明了编译器后端处理该操作数时，
解码器和编码器使用的C++类。
最后，simm12继承自ImmLeaf类，
该类带有一个必须满足的条件，
指令选择期间，
DAG中的叶节点必须满足该条件才能匹配simm12类(稍后将详细介绍!)。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;simm12 :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Operand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ImmLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;isInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;}]&amp;gt; {&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ParserMatchClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;SImmAsmOperand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;EncoderMethod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;getImmOpValue&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;DecoderMethod&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;decodeSImmOperand&amp;lt;12&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;MCOperandPredicate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;int64_t&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Imm&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;MCOp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;evaluateAsConstantImm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;isInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;MCOp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;isBareSymbolRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OperandType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;OPERAND_SIMM12&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OperandNamespace&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;RISCWOp&quot;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;hasSideEffects&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;mayStore&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;in&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ALU_ri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;funct3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInstI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;funct3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OPC_OP_IMM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;outs&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ins&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;simm12:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$imm12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;err&quot;&gt;opcodestr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$rd, $rs1, $imm12&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt;
      &lt;span class=&quot;err&quot;&gt;Sched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;WriteIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ReadIALU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在一些计算机体系结构中（如RISCV）有一些指令是其他指令的别名。
通常，这样做只是为了方便或提高汇编代码的可读性。
例如，RISCV没有专门的寄存器-寄存器移动指令，只能使用不带立即数的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDI&lt;/code&gt;指令代替。
我们可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InstAlias&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MnemonicAlias&lt;/code&gt;类告诉LLVM我们的别名:&lt;/p&gt;

&lt;h3 id=&quot;合法化&quot;&gt;合法化&lt;/h3&gt;

&lt;p&gt;类型和操作的合法化阶段均在后端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetLowering&lt;/code&gt;子类中使用C++代码进行配置。
在RISCW中，此类为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetLowering&lt;/code&gt;，其代码在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib/Target/RISCW/RISCWISelLowering.cpp&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib/Target/RISCW/RISCWISelLowering.h&lt;/code&gt;中。
我们为支持算术指令所做的大多数更改实际上都在构造函数中。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;RISCWTargetLowering:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:RISCWTargetLowering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;TargetMachine&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;TM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                         &lt;span class=&quot;err&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RISCWSubtarget&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;STI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;TargetLowering&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Subtarget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;STI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;addRegisterClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;MVT:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;RISCW:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:GPRRegClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;err&quot;&gt;setSchedulingPreference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Sched:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:RegPressure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;err&quot;&gt;setOperationAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;ISD:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:SRA_PARTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;MVT:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Custom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;err&quot;&gt;setOperationAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;ISD:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:ROTL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;nl&quot;&gt;MVT:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Expand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有几件事值得注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addRegisterClass&lt;/code&gt;用于配置LLVM寄存器组和对应的寄存器类型，此信息用于类型合法化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setSchedulingPreference&lt;/code&gt;用于配置调度和形成阶段。这里我们告诉LLVM使用一个最小化寄存器压力的算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setOperationAction&lt;/code&gt;用于配置LLVM如何使操作合法化，即合法化Section DAG中的节点。
回想一下，有三个选项：扩展、提升和自定义。
LLVM会自动处理前两个操作，
例如，RISCV没有位旋转指令，因此我们要求编译器将该操作扩展为其他操作，如移位和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ors&lt;/code&gt;以模拟旋转。
标记为自定义的操作在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetLowering&lt;/code&gt;子类中由C++代码处理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每当LLVM在合法化过程中遇到具有custom操作的DAG节点时，
都会生成对&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetLoweing&lt;/code&gt;类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LowerOperation&lt;/code&gt;方法的回调。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHL_PARTS&lt;/code&gt;操作用于将64位整数左移。
我们通过构造函数中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setOperationAction(ISD:：SHL_PARTS，MVT:：i32，Custom)&lt;/code&gt;来告诉LLVM，
我们实现了一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LowerShlParts&lt;/code&gt;函数来来合法化此操作。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LowerShlParts&lt;/code&gt;用32位移位和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ors&lt;/code&gt;等其他合法操作来代替&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHL_PARTS&lt;/code&gt;节点。
我鼓励您看看代码，看看这是如何工作的！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：需要合法化的操作完全取决于后端实现的指令集，
以及TableGen代码中DAG节点与指令匹配的程度（下一节将对此进行详细介绍！）。
如果使某些操作合法化太复杂或发出的代码效率低下，
则说明您的指令集可能缺少某些指令！&lt;/p&gt;

&lt;h3 id=&quot;目标指令选择&quot;&gt;目标指令选择&lt;/h3&gt;

&lt;p&gt;目标指令选择阶段将后端TableGen文件中提供的DAG模式匹配到Section DAG中的节点。
匹配成功时，Section DAG中的节点将被替换为具体机器(或伪)指令的节点。
因此，TableGen定义的模式的质量对于发出好的代码至关重要，
您应该多花费些时间来调整这些模式!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;TableGen模式通常定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrInfo.td&lt;/code&gt;文件的末尾。&lt;/p&gt;

&lt;p&gt;模式records继承自LLVM的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pat&lt;/code&gt;类，
该类有两个参数，
第一个参数是一个包含要匹配的模式DAG，第二个参数是一个带有机器指令的DAG。
当模式匹配DAG中的某个内容时，匹配的节点被第二个参数中的DAG替换。&lt;/p&gt;

&lt;p&gt;不出所料，我们将使用一些类来帮助我们简化模式的定义。
这里有两个这样的类：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PatGprGpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;SDPatternOperator&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OpNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInst&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;OpNode&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PatGprSimm12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;SDPatternOperator&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;OpNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RWInstI&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;OpNode&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;simm12:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$imm12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Inst&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;GPR:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;simm12:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$imm12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PatGprGpr&lt;/code&gt;用带有两个通用寄存器操作数作为输入的指令替换DAG中的节点。
例如，下面是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;指令的模式声明:&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;def :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PatGprGpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PatGprSimm12&lt;/code&gt;将DAG中的节点替换为具有一个通用输入操作数和一个12位立即数的指令。
为了实现这一点，用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simm12&lt;/code&gt;取代了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pat&lt;/code&gt;中第一个和第二个参数中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPR&lt;/code&gt;。
回想一下，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simm12&lt;/code&gt;是我们在本文前一节中讨论过的一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;record&lt;/code&gt;。
它继承自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operand&lt;/code&gt;类，因此可以在指令的定义中使用。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simm12&lt;/code&gt;也继承自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImmLeaf&lt;/code&gt;类，因此也可以在模式定义中使用。
下面是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDI&lt;/code&gt;指令的定义，该指令接受一个立即数:&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;def :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;PatGprSimm12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ADDI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImmLeaf&lt;/code&gt;类是用于匹配立即数的模式。
它的参数是即时类型，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I32&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;I16&lt;/code&gt;以及谓词等。
谓词即C++代码块，
它检查指定模式必须满足的条件。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;simm12&lt;/code&gt;有一个谓词&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return isInt&amp;lt;12&amp;gt;(Imm)&lt;/code&gt;来检查整数是否在12位范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;有时，同一条指令可以与Selection DAG中的多个模式匹配。
在这种情况下，使用LLVM的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PatFrag&lt;/code&gt;类和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pat&lt;/code&gt;来避免代码重复，
如RISCW的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bit-shift&lt;/code&gt;模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;RISCW和RISCV后端首先声明指令，
并分别提供模式record。
然而，其他后端，如ARM或XCore，以不同的方式创建Instruction的子类，以便它们接受一个模式参数。
这种方法减少了代码行数，因为模式可以在定义指令的同一record中提供，
但在我看来，这使得TableGen代码更难阅读(也更难解释!)&lt;/p&gt;

&lt;p&gt;当在DAG中找到匹配时，
Pat的第二个参数也可以转换操作数(通常是立即数)。
为此，我们首先需要声明一个继承自&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDNodeXForm&lt;/code&gt;的操作节点。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDNodeXForm&lt;/code&gt;以实现所需转换的一段c++代码作为参数。
然后，我们在模式中使用新声明的节点，如下面的示例所示。
在本例中，HI20节点提取立即数的20个最重要的比特位。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;HI20 :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;SDNodeXForm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CurDAG-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;getTargetConstant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;N-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;getZExtValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0x800&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0xfffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                   &lt;span class=&quot;err&quot;&gt;SDLoc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;N-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;getValueType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}]&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;def :&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;simm32hi20:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;LUI&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;HI20&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;imm:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&amp;gt;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDNodeXForm&lt;/code&gt;节点不插入实际指令。
它们通常用于转换即时数据，因此可以在代码发出之前就完全解析。&lt;/p&gt;

&lt;p&gt;随着指令选择的进行，LLVM每个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Selection DAG&lt;/code&gt;节点调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SelectionDAGISel&lt;/code&gt;子类的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Select&lt;/code&gt;方法。
因此，后端可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Select&lt;/code&gt;方法中提供代码，
实现复杂的模式匹配，
而这种匹配在TableGen中很难表达。
例如，RISCW的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Select&lt;/code&gt;方法包括用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x0&lt;/code&gt;寄存器来替换常量0的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SelectionDAGISel&lt;/code&gt;子类通常在文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/&amp;lt;backend&amp;gt;/&amp;lt;backend&amp;gt;ISelDAGToDAG.h&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/&amp;lt;backend&amp;gt;/&amp;lt;backend&amp;gt;ISelDAGToDAG.cpp&lt;/code&gt;中。
例如，RISCW后端相关代码在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/RISCWISelDAGToDAG.h&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/RISCWISelDAGToDAG.cpp&lt;/code&gt;中。&lt;/p&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;p&gt;实际上有很多方法可以实现一个体系结构的LLVM后端，
所以在使用任何一种方法之前，请确保评估最适合您的需求的方法。
另外，请记住下面的TableGen类的简介，在编写后端时几乎肯定需要这些类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Register&lt;/strong&gt; 	Register declarations&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RegisterClass&lt;/strong&gt; 	Register Class declarations&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Instruction&lt;/strong&gt; 	Instruction declarations&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operand&lt;/strong&gt; 	Instruction operands&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImmLeaf&lt;/strong&gt; 	Pattern-matching immediates&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SDNodeXForm&lt;/strong&gt; 	Transforming immediates after a match&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pat&lt;/strong&gt; 	Providing a pattern to match in the Selection DAG&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PatFrag&lt;/strong&gt; 	Providing a pattern fragment with multiple patterns to match in the Selection DAG&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;关于RISCV指令格式的完整描述见参考手册的第2章 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 算术指令 现在，我们将把上一篇文章讨论的关于LLVM后端中的指令选择付诸实践。 我们将通过查看RISCW后端的算术指令(比如加法、减法和乘法)的具体实现来做到这一点。 注意：这篇文章中讨论的代码可以在这里找到。 RISCW的算术指令相对简单， 在指令选择过程中仅需要配置指令选择器和合法化器，这主要需编写三部分代码。 首先，使用TableGen描述目标平台支持的指令集。 其次，通知LLVM需要合法化的算术运算和类型。 最后，添加自定义C++代码来增强指令选择器的功能。 注意：在为不同体系结构实现指令选择时，总体思路大致相似，但是具体情况将有所不同。 例如，您的指令集可能具有有趣的/复杂的算术指令，例如长乘或多次累加，可能需要额外的代码来正确地支持这些指令。 另外，我们不会自定义优化，但是您可以查看其他后端有关自定义优化的内容，例如XCore和ARM有很多很好的例子。 注意：这里显示的大部分代码最初来自LLVM现有的RISCV后端，但是为了照顾本教程的读者，它已经被大大简化了。 TableGen TableGen是描述体系结构（包括寄存器，指令集，调用约定等）的专用编程语言， 其目标是创建可维护、易于阅读的代码来描述体系结构。 在构建LLVM时，TableGen工具将TableGen代码翻译为C++并将其与手工编码的C++文件一起编译。 注意：实际上，我发现TableGen代码很难阅读，更难编码！ 简而言之，TableGen是具有以下功能的声明性编程语言： 有两个主要组件： record和class。 record是class的实例，包含了名称和相关字段的值。 class是record的抽象，可用于生成具体的record。 两者相互配合可以很好地提取公共代码并减少重复。 record可以从一个或多个class继承，还可以定义自己的字段。 字段具有名称和值（或值列表），值具有特定的类型（如bit或int）。这是类型列表。 include指令用于将TableGen代码从一个文件包含到另一个文件中，就像C的#include一样。 以下是从LLVM文档中获取的示例，其中显示了一个非常简单的TableGen文件。 它包含一个classC，该class定义了值为1的bit类型的字段V， 还声明了一个从类C派生的记录X。 class C { bit V = 1; } def X : C; 后端需要定义TableGen的record，用以声明指令、寄存器等。 这些record必须从内部类继承，这样TableGen工具才能魔术地为这些record生成适当的C++代码。 例如，声明寄存器的record必须从内部的Register类继承。 在这篇文章中，我们将查看声明寄存器和指令的TableGen代码。 注意:TableGen文档在解释它是什么和语法方面做得很好。 但是，介绍后端应该重用的内部类和预定义记录的文档却很少；要了解这些内容您必须查看源代码。 注意:回想一下之前的文章， 我们的CMake文件使用带各种参数的TableGen命令把扩展名为.td的TableGen代码文件转化为扩展名为.inc的C++文件。 在构建系统发出TableGen命令之后，可以在build/lib/Target/RISCW的构建目录中找到生成的文件。 Tablegen的参数可以这里(非常简短地)查看。 注意:TableGen还可以配置指令选择过程中的调度和形成阶段，但是我不会在本教程中讨论这一点。 如果你感兴趣，可以看看这个视频。 定义寄存器 RISCW的寄存器定义非常简单， 可以在llvm/lib/Target/RISCW/RISCWRegisterInfo.td中找到。 让我们对其进行剖析，以了解TableGen的工作方式。 在文件的顶部，我们找到以下类。 let Namespace = &quot;RISCW&quot; in { class RISCWReg&amp;lt;bits&amp;lt;5&amp;gt; Enc, string n, list&amp;lt;string&amp;gt; alt = []&amp;gt; : Register&amp;lt;n&amp;gt; { let HWEncoding{4-0} = Enc; let AltNames = alt; } } // end Namespace 该代码声明了一个RISCWReg类，该类继承自在include/llvm/Target/Target.td中定义的内部类Register。 该代码还告诉我们，从此类继承时，我们必须提供最多三个参数： 寄存器编码Enc，它是类型为bits&amp;lt;5&amp;gt;的5位整数。 字符串n，表示人类可读的寄存器名称，如RISCV中的x0、x1等。 寄存器的别名列表，该列表是可选的。 例如，RISCV中的x2也可以称为sp，即堆栈指针。 但请注意，此列表是可选的，因为可以声明没有别名的寄存器，如果寄存器没有别名，则把alt设置[]。 另外，请注意Register类接受一个参数：类型为字符串的寄存器名称。 RISCWReg的其余两个参数（Enc和alt）被let语句用于覆盖Register类定义的HWEncoding和AltNames域。 您可以在这里和这里阅读Register的代码。 接下来，我们在该文件中找到以下Register定义。 每一行代码都是一个record，它定义了一个寄存器。 这些record继承自两个类:RISCWReg(我们已经讨论过了)和DwarfRegNum。 DwarfRegNum是这里定义的另一个内部类，用于为GCC和GDB提供调试信息。 def X0 : RISCWReg&amp;lt;0, &quot;x0&quot;, [&quot;zero&quot;]&amp;gt;, DwarfRegNum&amp;lt;[0]&amp;gt;; ... def X31 : RISCWReg&amp;lt;31,&quot;x31&quot;, [&quot;t6&quot;]&amp;gt;, DwarfRegNum&amp;lt;[31]&amp;gt;; 文件的最后几行定义寄存器组， RISCW定义了两种寄存器组：GPR通用寄存器和堆栈指针SP寄存器。 def GPR : RegisterClass&amp;lt;&quot;RISCW&quot;, [i32], 32, (add (sequence &quot;X%u&quot;, 10, 17), (sequence &quot;X%u&quot;, 5, 7), (sequence &quot;X%u&quot;, 28, 31), (sequence &quot;X%u&quot;, 8, 9), (sequence &quot;X%u&quot;, 18, 27), (sequence &quot;X%u&quot;, 0, 4) )&amp;gt;; def SP : RegisterClass&amp;lt;&quot;RISCW&quot;, [i32], 32, (add X2)&amp;gt;; 定义Register组的record继承自RegisterClass类，后者具有四个参数（还有一个可选的第五个参数，我们将不讨论）： 命名空间在我们的例子中是RISCW，这与我们在上面的RISCWReg类中重写的名称空间字段相匹配。 此组寄存器支持的数据类型列表。 这是一个列表，因为某些体系结构中的寄存器可以支持多种数据类型。 例如，一些64位计算机的寄存器可以在32位和64位模式下工作。 RISCW只适用于32位机器，因此寄存器总是32位，它们的类型就是i32。 从内存中存储或加载寄存器时寄存器的对齐方式。 一个DAG，指示此寄存器组包含的寄存器。还有… 我是说DAG！注意，GPR的DAG有一个ADD模式，该模式有6个sequence节点。 sequence是一种操作，它接受字符串格式参数以及起始值和结束值。 序列中的每个元素都是TableGen工具根据格式参数指定的格式生成。 所以，这个DAG的另一种写法是(add X10, X17,…, X3, X4)。 此DAG还指定了寄存器分配器使用寄存器的顺序。 例如，如果两者都可用，分配器将优先使用来自GPR的x10而不是x4。 寄存器组稍后用于配置合法化器。 定义指令 计算机体系结构使用一组格式对指令进行编码。 例如，RISCV体系结构使用32位编码和4种基本指令格式来编码指令3。 此外，每种格式都有一组唯一的操作码(或操作码)。 然后使用格式和操作码对特定指令进行编码，这使处理器能够识别指令并确定它们的操作数。 在LLVM中，定义指令的方式与定义指令集编码的方式类似。 定义指令的代码通常由两部分组成: 格式定义和指令定义。 定义格式 定义格式的同时也定义了唯一的标识符， 这些标识符指示指令的格式， C++代码使用它来正确地发出指令编码。 RISCW后端定义格式的代码，如下所示: class InstFormat&amp;lt;bits&amp;lt;5&amp;gt; val&amp;gt; { bits&amp;lt;5&amp;gt; Value = val; } def InstFormatPseudo : InstFormat&amp;lt;0&amp;gt;; def InstFormatR : InstFormat&amp;lt;1&amp;gt;; ... def InstFormatOther : InstFormat&amp;lt;17&amp;gt;; 注意： 在LLVM后端中，定义指令格式的代码通常在文件llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrFormats.td中， 而实际定义指令的代码在文件llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrInfo.td中。 但是在复杂的后端中， 指令定义可以拆分为多个文件， 例如，RISCV的每个扩展都对应一个不同的文件。 这些文件称为llvm/lib/Target/RISCV/RISCVInstrInfo&amp;lt;EXT&amp;gt;.td， 其中&amp;lt;EXT&amp;gt;是扩展字母，如M，A等。 RISCW后端相对简单， 用于定义格式和指令的TableGen代码分别存储在llvm/lib/Target/RISCW/RISCWInstrFormats.td和llvm/lib/Target/RISCWInstrInfo.td中。 注意:RISCW后端基于RISCV后端。 两者都试图严格地根据RISCV的参考手册定义指令， 但这不是必须的。 你也可以针对你的体系结构和编译器构造只属于你的TableGen代码。 RISCW后端为操作码定义了如下record: class RISCWOpcode&amp;lt;bits&amp;lt;7&amp;gt; val&amp;gt; { bits&amp;lt;7&amp;gt; Value = val; } def OPC_LOAD : RISCWOpcode&amp;lt;0b0000011&amp;gt;; def OPC_LOAD_FP : RISCWOpcode&amp;lt;0b0000111&amp;gt;; ... def OPC_SYSTEM : RISCWOpcode&amp;lt;0b1110011&amp;gt;; 所有指令必须继承自LLVM内部的Instruction类。 方便起见，RISCW后端还定义了Instruction的子类RWInst， 它覆盖了许多字段，例如Size和TSFlags，同时添加了额外的字段。 Instruction类实际上非常庞大， 需要配置许多选项， 我建议您通读LLVM的源代码以了解什么样的配置可以满足你的需求。 class RWInst&amp;lt;dag outs, dag ins, string opcodestr, string argstr, list&amp;lt;dag&amp;gt; pattern, InstFormat format&amp;gt; : Instruction { field bits&amp;lt;32&amp;gt; Inst; field bits&amp;lt;32&amp;gt; SoftFail = 0; let Size = 4; ... let TSFlags{4-0} = format.Value; } 注意：Instruction类中的许多字段仅对特定任务有用。 例如，仅当发出目标代码时才使用Inst字段和opcode。 因此，不要理会您不需要的东西！ 再次为方便起见， RISCW后端为每种格式定义了RWInst类的子类。 我们实际的指令将继承这些“低级的”格式，以避免代码重复。 格式类根据相关格式的编码覆盖Inst字段的值。 另外，还有一个特殊的Pseudo类，用于设置Instruction类中的isPseudo字段。 这些pseudo指令通常是栈调整和函数返回等操作的占位符， 我们将在后面的文章中进行探讨。 class Pseudo&amp;lt;dag outs, dag ins, list&amp;lt;dag&amp;gt; pattern, string opcodestr = &quot;&quot;, string argstr = &quot;&quot;&amp;gt; : RWInst&amp;lt;outs, ins, opcodestr, argstr, pattern, InstFormatPseudo&amp;gt;, Sched&amp;lt;[]&amp;gt; { let isPseudo = 1; let isCodeGenOnly = 1; } class RWInstR&amp;lt;bits&amp;lt;7&amp;gt; funct7, bits&amp;lt;3&amp;gt; funct3, RISCWOpcode opcode, dag outs, dag ins, string opcodestr, string argstr&amp;gt; : RWInst&amp;lt;outs, ins, opcodestr, argstr, [], InstFormatR&amp;gt; { bits&amp;lt;5&amp;gt; rs2; bits&amp;lt;5&amp;gt; rs1; bits&amp;lt;5&amp;gt; rd; let Inst{31-25} = funct7; ... let Opcode = opcode.Value; } ... 关于这些TableGen类，有几点需要强调： funct *和opcode参数用于形成唯一的操作码，该操作码用于将指令编码为二进制。 outs和ins参数是DAG，分别指定指令的输出和输入操作数。 操作数通常是寄存器或立即数，但也可以是堆栈帧位置，全局地址等。 opcodestr是指令的助记符，例如ADD用于加法，SUB用于减法，等等。 argstr参数是一种格式字符串，用于告诉LLVM如何在汇编中打印指令的操作数。 例如，如果outs参数说有一个$r1寄存器操作数， 而ins参数说有一个$r2寄存器操作数并且argstr的格式为&quot;$r1,$r2&quot;， 则该指令的汇编将首先显示输出操作数（即紧随助记符之后）然后显示,，然后显示输入操作数。 在Pseudo中，还有一个pattern操作数， 它告诉LLVM在目标指令选择阶段可以用该指令替换DAG中的哪些节点。 更详细的细节以后再讨论！ 定义指令 为了方便起见，还定义了另一个类， 该类可以根据操作数以及操作是否涉及ALU、内存等来简化指令的定义。 例如，我们有下面的ALU_rr类来定义使用ALU（算数逻辑单元）的指令， 该类有三个GPR类型的操作数:两个是输入，一个是输出。 显然，所有ALU_rr指令都是R格式的，因为该类继承自 RWInstR。 另外，ALU_rr的定义位于let块中， 它覆盖了Instruction中值为0的hasSideEffects、mayLoad和mayStore字段； 这些字段中的大多数都是不言自明的，不过我鼓励您阅读代码以获得更多信息。 let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in class ALU_rr&amp;lt;bits&amp;lt;7&amp;gt; funct7, bits&amp;lt;3&amp;gt; funct3, string opcodestr&amp;gt; : RWInstR&amp;lt;funct7, funct3, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2), opcodestr, &quot;$rd, $rs1, $rs2&quot;&amp;gt;; 通过继承ALU_rr类来定义指令实际上非常简单。 例如，以下是定义ADD指令的代码： def ADD : ALU_rr&amp;lt;0b0000000, 0b000, &quot;add&quot;&amp;gt;, Sched&amp;lt;[WriteIALU, ReadIALU, ReadIALU]&amp;gt;; TableGen代码很难理解，因为大多数后端都使用深层继承来减少代码重复。 您可能需要拿出笔和纸来手动展开一些记录，以了解其工作原理。 例如，展开ADD的第一级看起来如下所示。 这个较长版本的ADD也是有效的TableGen代码， 将以前版本的ADD替换为这个较长的版本， LLVM仍然可以毫无问题地构建！ let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in def ADD : RWInstR&amp;lt;0b0000000, 0b000, OPC_OP, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2), &quot;add&quot;, &quot;$rd, $rs1, $rs2&quot;&amp;gt;, Sched&amp;lt;[WriteIALU, ReadIALU, ReadIALU]&amp;gt;; 定义带有立即数(而不是寄存器)的指令的方法大致相同， 但必须调整输入操作数。 例如，下面显示的ALU_ri类的第二个输入是名为$imm12的12位立即数(类型为simm12)。 simm12的定义证实该类的类型为i32还指明了编译器后端处理该操作数时， 解码器和编码器使用的C++类。 最后，simm12继承自ImmLeaf类， 该类带有一个必须满足的条件， 指令选择期间， DAG中的叶节点必须满足该条件才能匹配simm12类(稍后将详细介绍!)。 def simm12 : Operand&amp;lt;i32&amp;gt;, ImmLeaf&amp;lt;i32, [{return isInt&amp;lt;12&amp;gt;(Imm);}]&amp;gt; { let ParserMatchClass = SImmAsmOperand&amp;lt;12&amp;gt;; let EncoderMethod = &quot;getImmOpValue&quot;; let DecoderMethod = &quot;decodeSImmOperand&amp;lt;12&amp;gt;&quot;; let MCOperandPredicate = [{ int64_t Imm; if (MCOp.evaluateAsConstantImm(Imm)) return isInt&amp;lt;12&amp;gt;(Imm); return MCOp.isBareSymbolRef(); }]; let OperandType = &quot;OPERAND_SIMM12&quot;; let OperandNamespace = &quot;RISCWOp&quot;; } ... let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in class ALU_ri&amp;lt;bits&amp;lt;3&amp;gt; funct3, string opcodestr&amp;gt; : RWInstI&amp;lt;funct3, OPC_OP_IMM, (outs GPR:$rd), (ins GPR:$rs1, simm12:$imm12) opcodestr, &quot;$rd, $rs1, $imm12&quot;&amp;gt;, Sched&amp;lt;[WriteIALU, ReadIALU]&amp;gt;; 在一些计算机体系结构中（如RISCV）有一些指令是其他指令的别名。 通常，这样做只是为了方便或提高汇编代码的可读性。 例如，RISCV没有专门的寄存器-寄存器移动指令，只能使用不带立即数的ADDI指令代替。 我们可以通过InstAlias和MnemonicAlias类告诉LLVM我们的别名: 合法化 类型和操作的合法化阶段均在后端的TargetLowering子类中使用C++代码进行配置。 在RISCW中，此类为RISCWTargetLowering，其代码在lib/Target/RISCW/RISCWISelLowering.cpp和lib/Target/RISCW/RISCWISelLowering.h中。 我们为支持算术指令所做的大多数更改实际上都在构造函数中。 RISCWTargetLowering::RISCWTargetLowering(const TargetMachine &amp;amp;TM, const RISCWSubtarget &amp;amp;STI) : TargetLowering(TM), Subtarget(STI) { addRegisterClass(MVT::i32, &amp;amp;RISCW::GPRRegClass); ... setSchedulingPreference(Sched::RegPressure); ... setOperationAction(ISD::SRA_PARTS, MVT::i32, Custom); ... setOperationAction(ISD::ROTL, MVT::i32, Expand); ... } 有几件事值得注意： addRegisterClass用于配置LLVM寄存器组和对应的寄存器类型，此信息用于类型合法化。 setSchedulingPreference用于配置调度和形成阶段。这里我们告诉LLVM使用一个最小化寄存器压力的算法。 setOperationAction用于配置LLVM如何使操作合法化，即合法化Section DAG中的节点。 回想一下，有三个选项：扩展、提升和自定义。 LLVM会自动处理前两个操作， 例如，RISCV没有位旋转指令，因此我们要求编译器将该操作扩展为其他操作，如移位和ors以模拟旋转。 标记为自定义的操作在TargetLowering子类中由C++代码处理。 每当LLVM在合法化过程中遇到具有custom操作的DAG节点时， 都会生成对TargetLoweing类的LowerOperation方法的回调。 例如，SHL_PARTS操作用于将64位整数左移。 我们通过构造函数中的setOperationAction(ISD:：SHL_PARTS，MVT:：i32，Custom)来告诉LLVM， 我们实现了一个LowerShlParts函数来来合法化此操作。 LowerShlParts用32位移位和ors等其他合法操作来代替SHL_PARTS节点。 我鼓励您看看代码，看看这是如何工作的！ 注意：需要合法化的操作完全取决于后端实现的指令集， 以及TableGen代码中DAG节点与指令匹配的程度（下一节将对此进行详细介绍！）。 如果使某些操作合法化太复杂或发出的代码效率低下， 则说明您的指令集可能缺少某些指令！ 目标指令选择 目标指令选择阶段将后端TableGen文件中提供的DAG模式匹配到Section DAG中的节点。 匹配成功时，Section DAG中的节点将被替换为具体机器(或伪)指令的节点。 因此，TableGen定义的模式的质量对于发出好的代码至关重要， 您应该多花费些时间来调整这些模式! 注意：TableGen模式通常定义在llvm/lib/Target/&amp;lt;BACKEND&amp;gt;/&amp;lt;BACKEND&amp;gt;InstrInfo.td文件的末尾。 模式records继承自LLVM的Pat类， 该类有两个参数， 第一个参数是一个包含要匹配的模式DAG，第二个参数是一个带有机器指令的DAG。 当模式匹配DAG中的某个内容时，匹配的节点被第二个参数中的DAG替换。 不出所料，我们将使用一些类来帮助我们简化模式的定义。 这里有两个这样的类： class PatGprGpr&amp;lt;SDPatternOperator OpNode, RWInst Inst&amp;gt; : Pat&amp;lt;(OpNode GPR:$rs1, GPR:$rs2), (Inst GPR:$rs1, GPR:$rs2)&amp;gt;; class PatGprSimm12&amp;lt;SDPatternOperator OpNode, RWInstI Inst&amp;gt; : Pat&amp;lt;(OpNode GPR:$rs1, simm12:$imm12), (Inst GPR:$rs1, simm12:$imm12)&amp;gt;; PatGprGpr用带有两个通用寄存器操作数作为输入的指令替换DAG中的节点。 例如，下面是ADD指令的模式声明: def : PatGprGpr&amp;lt;add, ADD&amp;gt;; PatGprSimm12将DAG中的节点替换为具有一个通用输入操作数和一个12位立即数的指令。 为了实现这一点，用simm12取代了Pat中第一个和第二个参数中的GPR。 回想一下，simm12是我们在本文前一节中讨论过的一个record。 它继承自Operand类，因此可以在指令的定义中使用。 simm12也继承自ImmLeaf类，因此也可以在模式定义中使用。 下面是ADDI指令的定义，该指令接受一个立即数: def : PatGprSimm12&amp;lt;add, ADDI&amp;gt;; 注意：ImmLeaf类是用于匹配立即数的模式。 它的参数是即时类型，例如I32、I16以及谓词等。 谓词即C++代码块， 它检查指定模式必须满足的条件。 例如，simm12有一个谓词return isInt&amp;lt;12&amp;gt;(Imm)来检查整数是否在12位范围内。 注意：有时，同一条指令可以与Selection DAG中的多个模式匹配。 在这种情况下，使用LLVM的PatFrag类和Pat来避免代码重复， 如RISCW的bit-shift模式。 注意:RISCW和RISCV后端首先声明指令， 并分别提供模式record。 然而，其他后端，如ARM或XCore，以不同的方式创建Instruction的子类，以便它们接受一个模式参数。 这种方法减少了代码行数，因为模式可以在定义指令的同一record中提供， 但在我看来，这使得TableGen代码更难阅读(也更难解释!) 当在DAG中找到匹配时， Pat的第二个参数也可以转换操作数(通常是立即数)。 为此，我们首先需要声明一个继承自SDNodeXForm的操作节点。 SDNodeXForm以实现所需转换的一段c++代码作为参数。 然后，我们在模式中使用新声明的节点，如下面的示例所示。 在本例中，HI20节点提取立即数的20个最重要的比特位。 def HI20 : SDNodeXForm&amp;lt;imm, [{ return CurDAG-&amp;gt;getTargetConstant(((N-&amp;gt;getZExtValue()+0x800) &amp;gt;&amp;gt; 12) &amp;amp; 0xfffff, SDLoc(N), N-&amp;gt;getValueType(0)); }]&amp;gt;; def : Pat&amp;lt;(simm32hi20:$imm), (LUI (HI20 imm:$imm))&amp;gt;; 注意：SDNodeXForm节点不插入实际指令。 它们通常用于转换即时数据，因此可以在代码发出之前就完全解析。 随着指令选择的进行，LLVM每个Selection DAG节点调用SelectionDAGISel子类的Select方法。 因此，后端可以在Select方法中提供代码， 实现复杂的模式匹配， 而这种匹配在TableGen中很难表达。 例如，RISCW的Select方法包括用x0寄存器来替换常量0的代码。 注意:SelectionDAGISel子类通常在文件llvm/lib/Target/&amp;lt;backend&amp;gt;/&amp;lt;backend&amp;gt;ISelDAGToDAG.h和llvm/lib/Target/&amp;lt;backend&amp;gt;/&amp;lt;backend&amp;gt;ISelDAGToDAG.cpp中。 例如，RISCW后端相关代码在llvm/lib/Target/RISCW/RISCWISelDAGToDAG.h和llvm/lib/Target/RISCW/RISCWISelDAGToDAG.cpp中。 结束语 实际上有很多方法可以实现一个体系结构的LLVM后端， 所以在使用任何一种方法之前，请确保评估最适合您的需求的方法。 另外，请记住下面的TableGen类的简介，在编写后端时几乎肯定需要这些类。 Register Register declarations RegisterClass Register Class declarations Instruction Instruction declarations Operand Instruction operands ImmLeaf Pattern-matching immediates SDNodeXForm Transforming immediates after a match Pat Providing a pattern to match in the Selection DAG PatFrag Providing a pattern fragment with multiple patterns to match in the Selection DAG 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617; 关于RISCV指令格式的完整描述见参考手册的第2章 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(四)：指令选择</title><link href="http://localhost:4000/blog/RISCW-4.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(四)：指令选择" /><published>2020-12-08T19:30:38+08:00</published><updated>2020-12-08T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-4</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-4.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;指令选择&quot;&gt;指令选择&lt;/h2&gt;

&lt;p&gt;我们先前简要介绍了LLVM后端的工作过程。
在这篇文章中，我们将更深入地了解这个过程的第一个阶段：指令选择。
我们的目的是在了解RISCW后端的具体实现之前，了解它的工作原理以及如何配置它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;a href=&quot;https://llvm.org/docs/CodeGenerator.html#instruction-selection-section&quot;&gt;LLVM文档&lt;/a&gt;对指令选择的工作原理给出了简短而清晰的描述，
这篇文章通过示例来重新说明这一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文中显示的示例是使用我们的RISCW后端框架构建的。可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/commit/274cfea0f9662f0ed49f6132b0424323d0b11750&quot;&gt;这里&lt;/a&gt;找到它的来源。&lt;/p&gt;

&lt;p&gt;指令选择过程将LLVM IR转化为指令序列，该指令序列使用了无穷数量的寄存器。
该过程分为以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;构建初始DAG&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;类型合法化&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;操作合法化&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;目标指令选择&lt;/li&gt;
  &lt;li&gt;调度和形成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我觉得通过例子来了解发生的事情会比较容易，我们将考虑指令选择如何转换下面的C程序。
该代码包含一个MUL函数，该函数接受64位参数x和32位参数y。
参数相乘，并返回32位整数结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;unsigned int MUL(unsigned long long int x, unsigned int y)
{
    return x * y;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;构建dag&quot;&gt;构建DAG&lt;/h3&gt;

&lt;p&gt;这是指令选择的第一阶段。
它接受LLVM IR作为输入，
并产生Selection DAG(有向无环图)作为输出。
指令选择过程中的每个其他阶段都在DAG上执行，直到产生输出指令序列。
正如前面几篇文章所讨论的，LLVM IR是前端工具(如Clang)根据C代码生成，随后由LLVM优化器进行优化。
下面是C程序的LLVM IR:&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dso_local&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@MUL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;local_unnamed_addr&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;entry:&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trunc&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%conv1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mul&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%y&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%conv1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Selection DAG实际上是一种精巧的树型数据结构，它表示LLVM IR中的基本块。 
基本块是不包含分支目的地（入口除外）和分支指令（出口除外）的指令序列。 
示例MUL函数非常简单，它只有一个称为入口的基本块，其他函数通常具有多个基本块。 
例如，下面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello&lt;/code&gt;函数具有四个基本块：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if.then&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if.else&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;。
每个基本块都将被转换为单独的DAG。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dso_local&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;local_unnamed_addr&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;entry:&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%cmp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;icmp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.else&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;if.then:&lt;/span&gt;                                          &lt;span class=&quot;c1&quot;&gt;; preds = %entry&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%call&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)*&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@hello100&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)*)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%return&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;if.else:&lt;/span&gt;                                          &lt;span class=&quot;c1&quot;&gt;; preds = %entry&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%call1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)*&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@helloOther&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)*)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%return&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;return:&lt;/span&gt;                                           &lt;span class=&quot;c1&quot;&gt;; preds = %if.else, %if.then&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%retval.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%call1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%retval.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Selection DAG具有以下属性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个节点都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDNode&lt;/code&gt;类的实例，代表一个操作，如加、减、乘等。
操作类型都定义在文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include/llvm/CodeGen/ISDOpcodes.h&lt;/code&gt;中。&lt;/li&gt;
  &lt;li&gt;每个节点都有0个或多个操作数，操作数由其他节点定义，用指向该节点的边表示，边是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDValue&lt;/code&gt;类的实例。&lt;/li&gt;
  &lt;li&gt;操作产生的值的类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTV&lt;/code&gt;（Machine Value Type），比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i8&lt;/code&gt;，它们分别表示1位和8位整数。&lt;/li&gt;
  &lt;li&gt;具有副作用的节点会强制对操作进行排序，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loads&lt;/code&gt;语句，它们具有类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVT::Other&lt;/code&gt;的特殊chain值，
既作为输入操作数又作为输出操作数。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ISD::EntryToken&lt;/code&gt;类型的叶节点是代码的入口。&lt;/li&gt;
  &lt;li&gt;DAG的根节点是带有链操作数的最终副作用节点。这是的代码块的最后一个操作，例如函数结尾处的返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;警告！&lt;/strong&gt;LLVM后端的类型系统非常有限。
当输入的LLVM IR被转换为DAG时，许多有用的类型信息被丢弃。
最值得注意的丢弃是指针类型，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVT&lt;/code&gt;类的类型列表完全没有包含指针类型。
因此，指针在DAG中使用整数类型表示，所以很难判断一个节点(如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;)的操作数是指针还是整数。&lt;/p&gt;

&lt;p&gt;这是我从MUL函数获得的初始Selection DAG。
&lt;img src=&quot;http://localhost:4000/assets/riscw/llvm-4-dag-before-combine1.png&quot; alt=&quot;Selection DAG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;入口节点位于图的顶部，而根节点位于底部。
还有一个由蓝色边连接的节点链，从根节点开始，到入口节点结束。
这些蓝边就是前面讨论过的链操作数。
黑色边显示的是值的流动，如整数和浮点数。
此Selection DAG的等效文本表示如下所示：&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;t0:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;EntryToken&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;t2:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CopyFromReg&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Register:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt;
        &lt;span class=&quot;nl&quot;&gt;t4:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CopyFromReg&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Register:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%1&lt;/span&gt;
      &lt;span class=&quot;nl&quot;&gt;t7:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;build_pair&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t4&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;t8:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;truncate&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t7&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;t6:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CopyFromReg&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Register:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%2&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;t9:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mul&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t6&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;t11:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;glue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CopyToReg&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Register:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t9&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;t12:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;RISCWISD:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:Ret&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;t11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;Register:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;t11:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;Selection DAG可以同时包含目标独立和目标相关的节点。
目标独立的操作定义在文件&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/include/llvm/CodeGen/ISDOpcodes.h#L40&quot;&gt;ISDOpcodes.h&lt;/a&gt;中。
目标相关的操作由每个后端定义，通常定义在声明TargetLowering子类的同一文件中。 
您可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/lib/Target/RISCW/RISCWISelLowering.h#L25&quot;&gt;llvm/lib/Target/RISCW/RISCWISelLowering.h&lt;/a&gt;中找到目标相关节点的定义。
上面显示的用于MUL的Selection DAG具有节点t12，该节点代表目标相关操作&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWISD::Ret&lt;/code&gt;，该函数表示从函数返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在指令选择过程的各个阶段，您可以通过向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llc&lt;/code&gt;命令传递&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-view-dag-combine1-dags&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-view-legalize-dags&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-view-dag-combine2-dags&lt;/code&gt;参数告诉LLVM生成Selection DAG的可视化表示，还可以通过向&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llc&lt;/code&gt;命令传递&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-debug&lt;/code&gt;参数告诉LLVM生成Selection DAG的文本表示。&lt;/p&gt;

&lt;h3 id=&quot;优化&quot;&gt;优化&lt;/h3&gt;

&lt;p&gt;指令选择阶段会有三次DAG优化过程，第一次优化发生在LLVM IR构建Selection DAG之后。
其余两次将在合法化阶段后执行。
根据LLVM文档，这些优化旨在简化可能由其他阶段(如合法化)生成的不必要的复杂Selection DAGs。&lt;/p&gt;

&lt;p&gt;就我所知，LLVM的优化过程就是通过运行一个编译pass将一组节点组合成更简洁的节点。
为了实现这一点，LLVM用这个巨大的C++文件(&amp;gt;20,000行)遍历DAG，并通过模式匹配来寻找优化机会。
例如，合并器可以将Selection DAG的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(add (add x, y) z)&lt;/code&gt;节点，转换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(add x，y + z)&lt;/code&gt;节点，从而消除了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;节点。&lt;/p&gt;

&lt;p&gt;下图显示了MUL示例函数第一遍优化后的Selection DAG。
与上一节中的Selection DAG相比，优化的DAG用节点t13代替了节点t3和t4。
该优化将丢弃64位整数x的高32位，因为函数MUL的返回值仅依赖x的低32位，
因此，可以通过消除t3和t4简化DAG。
&lt;img src=&quot;http://localhost:4000/assets/riscw/llvm-4-dag-before-legalize-types.png&quot; alt=&quot;Selection DAG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LLVM的DAG合成器只优化目标独立的操作，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ISDOpcodes.h&lt;/code&gt;中定义的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;store&lt;/code&gt;等。
通过覆盖&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetlower&lt;/code&gt;子类中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PerformDAGCombine&lt;/code&gt;函数，
后端可以为合成器提供额外的优化功能，这些功能可以是目标独立的也可以是目标依赖的。
此外，后端必须通知优化器受支持的目标独立的节点，
这通过在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;targetlower&lt;/code&gt;类的子类的构造函数中调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTargetDAGCombine&lt;/code&gt;函数完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;令人困惑的是，LLVM后端的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetLowering&lt;/code&gt;子类通常在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;TARGET_NAME&amp;gt;ISelLowering.cpp&lt;/code&gt;文件中实现。
您可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/RISCWISelLowering.cpp&lt;/code&gt;中找到RISCW的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;XCore后端有一个很好的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PerformDAGCombine&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTargetDAGCombine&lt;/code&gt;例子（参见&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/lib/Target/XCore/XCoreISelLowering.cpp#L1590&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/lib/Target/XCore/XCoreISelLowering.cpp#L170&quot;&gt;这里&lt;/a&gt;）
——我的意思是很容易阅读。
另外，看看&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/lib/Target/XCore/XCoreISelLowering.cpp#L1739&quot;&gt;这个后端&lt;/a&gt;是如何将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add(add(mul(x，y)，a)，b)&lt;/code&gt;节点组合到更简单的目标依赖的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lmul(x，y，a，b)&lt;/code&gt;节点，
因为XCore架构有一个乘法累加指令&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h3 id=&quot;类型和操作合法化&quot;&gt;类型和操作合法化&lt;/h3&gt;

&lt;p&gt;上面显示的优化的DAG包含一个节点t7，
它会产生一个i64类型的值，
但是RISCW机器只支持32位。
合法化阶段会解决这些问题。&lt;/p&gt;

&lt;p&gt;首先执行的是类型合法化，
它将DAG转换为仅使用本地计算机原生支持的数据类型。
为了实现这一点，它将小类型转换或提升为较大的类型；
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i1&lt;/code&gt;类型的1位整数转换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32&lt;/code&gt;类型的32位整数。
此外，编译器将大整数分解或展开为较小的整数，例如在32位计算机中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i64&lt;/code&gt;类型的64位整数被转换为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32&lt;/code&gt;类型的32位整数。
下面的DAG是前面展示的DAG的合法化版本。
在本例中，编译器消除了t3和t7节点，以确保新的DAG只使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i32&lt;/code&gt;整数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/riscw/llvm-4-dag-before-combine2.png&quot; alt=&quot;Selection DAG&quot; /&gt;&lt;/p&gt;

&lt;p&gt;操作合法化在第二个优化阶段之后执行。
它将DAG转换为仅使用本地计算机原生支持的操作。
例如，DAG可能包含bit-rotate left（rotl）节点，但目标指令集可能不支持该指令，
因此，操作合法化把该操作转化为移位和或运算的联合操作。&lt;/p&gt;

&lt;p&gt;有三种使操作合法化的策略。
首先，将不受支持的操作扩展为一组受支持的操作来模拟原不受支持的操作。
其次，把类型提升为更大的类型，以支持缺失的操作。
第三，使用TargetLowering类的子类中的钩子在C++中实现自定义的合法化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在以后的文章中，我将解释后端如何配置合法化阶段。
这可以在TargetLowering类的子类的构造函数中完成。&lt;/p&gt;

&lt;h3 id=&quot;指令选择-1&quot;&gt;指令选择&lt;/h3&gt;
&lt;p&gt;此时，DAG包含大部分目标独立（如加和减）节点，以及一小部分目标依赖节点（如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWISD::Ret&lt;/code&gt;）。 
下一步，需要将这些抽象操作映射到目标架构的具体机器指令，
LLVM在指令选择阶段会对此进行处理。 
处理方法很简单：编译器通过模式匹配将DAG中的节点映射成机器指令。 
指令的模式和描述由编译器后端的开发人员通过&lt;a href=&quot;https://llvm.org/docs/TableGen/ProgRef.html&quot;&gt;TableGen&lt;/a&gt;代码提供。 
另外，可以使用C++直接编写难以使用TableGen描述的复杂模式。&lt;/p&gt;

&lt;p&gt;我们将在以后的文章中更仔细地研究TableGen。
现在，让我们考虑一下LLVM如何将合法且优化的DAG映射成下面显示的新DAG。
在这种情况下，只有两个节点需要更改。
t9用指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MUL&lt;/code&gt;替换了mul操作，而t12用指令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PseudoRet&lt;/code&gt;替换了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWISD::Ret&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/riscw/llvm-4-dag-before-scheduler.png&quot; alt=&quot;Selection DAG&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;调度和形成&quot;&gt;调度和形成&lt;/h3&gt;

&lt;p&gt;谢天谢地，这里没什么好说的，因为帖子已经很长了！
此阶段根据某些约束将DAG转换为指令列表。
例如，后端可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetLowering&lt;/code&gt;子类的构造函数调用&lt;a href=&quot;https://github.com/andresag01/llvm-project/blob/274cfea0f9662f0ed49f6132b0424323d0b11750/llvm/include/llvm/CodeGen/TargetLowering.h#L1939&quot;&gt;setSchedulingPreference&lt;/a&gt;来指定调度选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;警告！&lt;/strong&gt; 一定要尝试不同的调度首选项！
如果调度策略与体系结构和处理器的特性不匹配，那么调度策略会显著降低所发出的代码的质量。
&lt;a href=&quot;&quot;&gt;这里&lt;/a&gt;列出了各种调度选项。&lt;/p&gt;

&lt;p&gt;下面是我们MUL函数的指令清单。
有几个重要的事情要注意。
首先，与实际机器的寄存器相反，生成的代码仍然使用一组无限多的虚拟寄存器；
编译器稍后会通过寄存器分配器来处理这个问题。
第二，已经存在一些对寄存器分配过程有用的生命周期信息；例如，有两个寄存器，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x0&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x2&lt;/code&gt;，
它们在基本块的开始处就处于活动状态。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;bb.0.entry:&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;liveins:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;COPY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;COPY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;MUL&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;COPY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%3&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:gpr&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;PseudoRET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;查看XCore XS1体系结构&lt;a href=&quot;https://www.xmos.ai/download/The-XMOS-XS1-Architecture(X7879A).pdf&quot;&gt;参考手册&lt;/a&gt;，了解乘法累加（LMUL）指令的详细说明。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 指令选择 我们先前简要介绍了LLVM后端的工作过程。 在这篇文章中，我们将更深入地了解这个过程的第一个阶段：指令选择。 我们的目的是在了解RISCW后端的具体实现之前，了解它的工作原理以及如何配置它。 注意：LLVM文档对指令选择的工作原理给出了简短而清晰的描述， 这篇文章通过示例来重新说明这一点。 注意：本文中显示的示例是使用我们的RISCW后端框架构建的。可以在这里找到它的来源。 指令选择过程将LLVM IR转化为指令序列，该指令序列使用了无穷数量的寄存器。 该过程分为以下几个阶段： 构建初始DAG 优化 类型合法化 优化 操作合法化 优化 目标指令选择 调度和形成 我觉得通过例子来了解发生的事情会比较容易，我们将考虑指令选择如何转换下面的C程序。 该代码包含一个MUL函数，该函数接受64位参数x和32位参数y。 参数相乘，并返回32位整数结果。 unsigned int MUL(unsigned long long int x, unsigned int y) { return x * y; } 构建DAG 这是指令选择的第一阶段。 它接受LLVM IR作为输入， 并产生Selection DAG(有向无环图)作为输出。 指令选择过程中的每个其他阶段都在DAG上执行，直到产生输出指令序列。 正如前面几篇文章所讨论的，LLVM IR是前端工具(如Clang)根据C代码生成，随后由LLVM优化器进行优化。 下面是C程序的LLVM IR: define dso_local i32 @MUL(i64 %x, i32 %y) local_unnamed_addr #0 { entry: %0 = trunc i64 %x to i32 %conv1 = mul i32 %0, %y ret i32 %conv1 } Selection DAG实际上是一种精巧的树型数据结构，它表示LLVM IR中的基本块。 基本块是不包含分支目的地（入口除外）和分支指令（出口除外）的指令序列。 示例MUL函数非常简单，它只有一个称为入口的基本块，其他函数通常具有多个基本块。 例如，下面的hello函数具有四个基本块：entry，if.then，if.else和return。 每个基本块都将被转换为单独的DAG。 define dso_local i32 @hello(i32 %x) local_unnamed_addr #0 { entry: %cmp = icmp eq i32 %x, 100 br i1 %cmp, label %if.then, label %if.else if.then: ; preds = %entry %call = tail call i32 bitcast (i32 (...)* @hello100 to i32 (i32)*)(i32 100) #2 br label %return if.else: ; preds = %entry %call1 = tail call i32 bitcast (i32 (...)* @helloOther to i32 (i32)*)(i32 %x) #2 br label %return return: ; preds = %if.else, %if.then %retval.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ] ret i32 %retval.0 } Selection DAG具有以下属性： 每个节点都是SDNode类的实例，代表一个操作，如加、减、乘等。 操作类型都定义在文件include/llvm/CodeGen/ISDOpcodes.h中。 每个节点都有0个或多个操作数，操作数由其他节点定义，用指向该节点的边表示，边是SDValue类的实例。 操作产生的值的类型为MTV（Machine Value Type），比如i1和i8，它们分别表示1位和8位整数。 具有副作用的节点会强制对操作进行排序，例如return和loads语句，它们具有类型为MVT::Other的特殊chain值， 既作为输入操作数又作为输出操作数。 ISD::EntryToken类型的叶节点是代码的入口。 DAG的根节点是带有链操作数的最终副作用节点。这是的代码块的最后一个操作，例如函数结尾处的返回。 警告！LLVM后端的类型系统非常有限。 当输入的LLVM IR被转换为DAG时，许多有用的类型信息被丢弃。 最值得注意的丢弃是指针类型，MVT类的类型列表完全没有包含指针类型。 因此，指针在DAG中使用整数类型表示，所以很难判断一个节点(如add)的操作数是指针还是整数。 这是我从MUL函数获得的初始Selection DAG。 入口节点位于图的顶部，而根节点位于底部。 还有一个由蓝色边连接的节点链，从根节点开始，到入口节点结束。 这些蓝边就是前面讨论过的链操作数。 黑色边显示的是值的流动，如整数和浮点数。 此Selection DAG的等效文本表示如下所示： t0: ch = EntryToken t2: i32,ch = CopyFromReg t0, Register:i32 %0 t4: i32,ch = CopyFromReg t0, Register:i32 %1 t7: i64 = build_pair t2, t4 t8: i32 = truncate t7 t6: i32,ch = CopyFromReg t0, Register:i32 %2 t9: i32 = mul t8, t6 t11: ch,glue = CopyToReg t0, Register:i32 $x0, t9 t12: ch = RISCWISD::Ret t11, Register:i32 $x0, t11:1 注意：Selection DAG可以同时包含目标独立和目标相关的节点。 目标独立的操作定义在文件ISDOpcodes.h中。 目标相关的操作由每个后端定义，通常定义在声明TargetLowering子类的同一文件中。 您可以在llvm/lib/Target/RISCW/RISCWISelLowering.h中找到目标相关节点的定义。 上面显示的用于MUL的Selection DAG具有节点t12，该节点代表目标相关操作RISCWISD::Ret，该函数表示从函数返回。 注意：在指令选择过程的各个阶段，您可以通过向llc命令传递-view-dag-combine1-dags，-view-legalize-dags，-view-dag-combine2-dags参数告诉LLVM生成Selection DAG的可视化表示，还可以通过向llc命令传递-debug参数告诉LLVM生成Selection DAG的文本表示。 优化 指令选择阶段会有三次DAG优化过程，第一次优化发生在LLVM IR构建Selection DAG之后。 其余两次将在合法化阶段后执行。 根据LLVM文档，这些优化旨在简化可能由其他阶段(如合法化)生成的不必要的复杂Selection DAGs。 就我所知，LLVM的优化过程就是通过运行一个编译pass将一组节点组合成更简洁的节点。 为了实现这一点，LLVM用这个巨大的C++文件(&amp;gt;20,000行)遍历DAG，并通过模式匹配来寻找优化机会。 例如，合并器可以将Selection DAG的(add (add x, y) z)节点，转换为(add x，y + z)节点，从而消除了add节点。 下图显示了MUL示例函数第一遍优化后的Selection DAG。 与上一节中的Selection DAG相比，优化的DAG用节点t13代替了节点t3和t4。 该优化将丢弃64位整数x的高32位，因为函数MUL的返回值仅依赖x的低32位， 因此，可以通过消除t3和t4简化DAG。 LLVM的DAG合成器只优化目标独立的操作，即ISDOpcodes.h中定义的add、sub、load、store等。 通过覆盖targetlower子类中的PerformDAGCombine函数， 后端可以为合成器提供额外的优化功能，这些功能可以是目标独立的也可以是目标依赖的。 此外，后端必须通知优化器受支持的目标独立的节点， 这通过在targetlower类的子类的构造函数中调用setTargetDAGCombine函数完成。 注意：令人困惑的是，LLVM后端的TargetLowering子类通常在&amp;lt;TARGET_NAME&amp;gt;ISelLowering.cpp文件中实现。 您可以在llvm/lib/Target/RISCW/RISCWISelLowering.cpp中找到RISCW的实现。 注意：XCore后端有一个很好的PerformDAGCombine和setTargetDAGCombine例子（参见这里和这里） ——我的意思是很容易阅读。 另外，看看这个后端是如何将add(add(mul(x，y)，a)，b)节点组合到更简单的目标依赖的lmul(x，y，a，b)节点， 因为XCore架构有一个乘法累加指令3。 类型和操作合法化 上面显示的优化的DAG包含一个节点t7， 它会产生一个i64类型的值， 但是RISCW机器只支持32位。 合法化阶段会解决这些问题。 首先执行的是类型合法化， 它将DAG转换为仅使用本地计算机原生支持的数据类型。 为了实现这一点，它将小类型转换或提升为较大的类型； 例如，i1类型的1位整数转换为i32类型的32位整数。 此外，编译器将大整数分解或展开为较小的整数，例如在32位计算机中，i64类型的64位整数被转换为i32类型的32位整数。 下面的DAG是前面展示的DAG的合法化版本。 在本例中，编译器消除了t3和t7节点，以确保新的DAG只使用i32整数。 操作合法化在第二个优化阶段之后执行。 它将DAG转换为仅使用本地计算机原生支持的操作。 例如，DAG可能包含bit-rotate left（rotl）节点，但目标指令集可能不支持该指令， 因此，操作合法化把该操作转化为移位和或运算的联合操作。 有三种使操作合法化的策略。 首先，将不受支持的操作扩展为一组受支持的操作来模拟原不受支持的操作。 其次，把类型提升为更大的类型，以支持缺失的操作。 第三，使用TargetLowering类的子类中的钩子在C++中实现自定义的合法化。 注意：在以后的文章中，我将解释后端如何配置合法化阶段。 这可以在TargetLowering类的子类的构造函数中完成。 指令选择 此时，DAG包含大部分目标独立（如加和减）节点，以及一小部分目标依赖节点（如RISCWISD::Ret）。 下一步，需要将这些抽象操作映射到目标架构的具体机器指令， LLVM在指令选择阶段会对此进行处理。 处理方法很简单：编译器通过模式匹配将DAG中的节点映射成机器指令。 指令的模式和描述由编译器后端的开发人员通过TableGen代码提供。 另外，可以使用C++直接编写难以使用TableGen描述的复杂模式。 我们将在以后的文章中更仔细地研究TableGen。 现在，让我们考虑一下LLVM如何将合法且优化的DAG映射成下面显示的新DAG。 在这种情况下，只有两个节点需要更改。 t9用指令MUL替换了mul操作，而t12用指令PseudoRet替换了RISCWISD::Ret。 调度和形成 谢天谢地，这里没什么好说的，因为帖子已经很长了！ 此阶段根据某些约束将DAG转换为指令列表。 例如，后端可以通过TargetLowering子类的构造函数调用setSchedulingPreference来指定调度选项。 警告！ 一定要尝试不同的调度首选项！ 如果调度策略与体系结构和处理器的特性不匹配，那么调度策略会显著降低所发出的代码的质量。 这里列出了各种调度选项。 下面是我们MUL函数的指令清单。 有几个重要的事情要注意。 首先，与实际机器的寄存器相反，生成的代码仍然使用一组无限多的虚拟寄存器； 编译器稍后会通过寄存器分配器来处理这个问题。 第二，已经存在一些对寄存器分配过程有用的生命周期信息；例如，有两个寄存器，即x0和x2， 它们在基本块的开始处就处于活动状态。 bb.0.entry: liveins: $x0, $x2 %2:gpr = COPY $x2 %0:gpr = COPY $x0 %3:gpr = MUL %0:gpr, %2:gpr $x0 = COPY %3:gpr PseudoRET implicit $x0 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617; 查看XCore XS1体系结构参考手册，了解乘法累加（LMUL）指令的详细说明。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(三)：配置构建系统</title><link href="http://localhost:4000/blog/RISCW-3.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(三)：配置构建系统" /><published>2020-12-08T12:30:38+08:00</published><updated>2020-12-08T12:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-3</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-3.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;配置构建系统&quot;&gt;配置构建系统&lt;/h2&gt;

&lt;p&gt;在前面，我们提到每个LLVM后端都有一个单独的目录&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM/lib/Target&lt;/code&gt;，后端的大部分代码都在其中。
此外，LLVM依赖CMake为实际的构建系统(如Make、Ninja等)生成构建文件。
在这篇文章中，我们将仔细研究其中的一些CMake配置文件。&lt;/p&gt;

&lt;p&gt;注意:RISCW后端代码可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/commit/274cfea0f9662f0ed49f6132b0424323d0b11750&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h3 id=&quot;cmake配置文件&quot;&gt;CMake配置文件&lt;/h3&gt;

&lt;p&gt;回想一下，RISCW后端存放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;目录下。
该目录及其子目录都有两个构建文件(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;)，描述后端模块的结构，提供链接信息等。
RISCW后端目前非常简单，目录结构是这样的:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm/lib/Target/RISCW
|- CMakeLists.txt
|- LLVMBuild.txt
|- Other C++, TableGen, etc files
|- TargetInfo/
|  |- CMakeLists.txt
|  |- LLVMBuild.txt
|  |- Other C++, TableGen, etc files
|- MCTargetDesc/
   |- CMakeLists.txt
   |- LLVMBuild.txt
   |- Other C++, TableGen, etc files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每个使用CMake的项目都会包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;文件&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，RISCW也不例外。
这些文件包含一系列CMake指令，这些指令用于驱动构建文件的生成。
在LLVM后端中，CMake会根据这些指令执行一些操作，例如指示要编译的C++源文件或生成TableGen指令。
LLVMBuild.txt文件对当前目录中包含的组件提供了描述。&lt;/p&gt;

&lt;h3 id=&quot;llvmbuildtxt文件&quot;&gt;LLVMBuild.txt文件&lt;/h3&gt;

&lt;p&gt;让我们看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/LLVMBuild.txt&lt;/code&gt;的内容。&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;subdirectories&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;MCTargetDesc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TargetInfo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;component_&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TargetGroup&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;has_asmprinter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;component_&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Library&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWCodeGen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;required_libraries&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;AsmPrinter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;CodeGen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;MC&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWDesc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWInfo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;SelectionDAG&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;add_to_library_groups&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该文件告诉构建系统RISCW后端具有两个组件。
其中一个是顶级组件RISCW，其类型为TargetGroup，该类型表明RISCW是一个后端，构建系统对该类型有一些特殊处理。 
Target是RISCW的父组件。 
请注意，此命名与LLVM后端的目录结构匹配，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;。
RISCW的名称也不是任意的，它必须与后端的TableGen文件中的定义匹配。&lt;/p&gt;

&lt;p&gt;LLVM后端提供了一系列可选功能，
例如assembly printing，assembly parsing等，
LLVMBuild.txt文件表明了后端支持哪些可选功能。
比如，最后一行告诉构建系统RISCW后端实现了assembly printing功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;查看现有后端（如ARM或RISCV）中的代码，以了解它们除了has_asmprinter之外还启用了哪些功能。&lt;/p&gt;

&lt;p&gt;LLVMBuild.txt文件还定义了第二个名为RISCWCodeGen的组件，其类型为Library，其父级为RISCW。
另外，文件还指明了RISCWCodeGen需要的依赖库，例如AsmPrinter，CodeGen等，构建LLVM时，缺少库会导致链接错误。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;的每个子目录也会包含一个LLVMBuild.txt文件，该文件使用RISCW作为父级来定义自己的组件。&lt;/p&gt;

&lt;h3 id=&quot;cmakeliststxt文件&quot;&gt;CMakeLists.txt文件&lt;/h3&gt;

&lt;p&gt;让我们看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/CMakeLists.txt&lt;/code&gt;文件的内容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM_TARGET_DEFINITIONS RISCW.td&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

tablegen&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM RISCWGenRegisterInfo.inc &lt;span class=&quot;nt&quot;&gt;-gen-register-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
tablegen&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM RISCWGenInstrInfo.inc &lt;span class=&quot;nt&quot;&gt;-gen-instr-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Other TableGen commands&lt;/span&gt;

add_public_tablegen_target&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;RISCWCommonTableGen&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# RISCWCodeGen should match with LLVMBuild.txt RISCWCodeGen&lt;/span&gt;
add_llvm_target&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;RISCWCodeGen
  RISCWAsmPrinter.cpp
  &lt;span class=&quot;c&quot;&gt;# Other files&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Should match with &quot;subdirectories =  MCTargetDesc TargetInfo&quot; in LLVMBuild.txt&lt;/span&gt;
add_subdirectory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TargetInfo&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
add_subdirectory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MCTargetDesc&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;文件顶部的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;命令将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_TARGET_DEFINITION&lt;/code&gt;定义为`RISCW.td**。
这个文件通常包含一些顶级定义，
并通过包含其他文件的方式来引入其他TableGen定义——我们将在后面的文章中更仔细地研究TableGen，
但是请随时查看代码库中的RISCW.td。&lt;/p&gt;

&lt;p&gt;然后我们在CMake文件中看到一些TableGen命令。
它们命令构建系统使TableGen工具根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.td&lt;/code&gt;文件生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWGen*.inc&lt;/code&gt;。
这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.inc&lt;/code&gt;文件实际上就是传统的C++代码，在编译完LLVM之后，你可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build/lib/Target/RISCW&lt;/code&gt;的构建目录中找到它们；它们可以用于调试，但是不容易阅读。&lt;/p&gt;

&lt;p&gt;接下来的命令，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_target&lt;/code&gt;，
指定了当前目录中要构建的C++文件，被指定的文件不能位于子目录中。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_target&lt;/code&gt;命令的第一个参数是目标的名称，并且应该与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;中定义名称匹配。&lt;/p&gt;

&lt;p&gt;最后，CMakeLists.txt指定了CMake应该查看的子目录，在后端RISCW中，只有两个:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetInfo&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MCTargetDesc&lt;/code&gt;。
子目录中的CMakeLists.txt与此类似，但要简单得多!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;后端文件的命名约定通常很重要，显然应该与构建文件的内容相匹配。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set(LLVM_TARGET_DEFINITIONS RISCW.td)&lt;/code&gt;命令要求&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCW.td&lt;/code&gt;存在!
一定要仔细检查这些错误，因为构建错误可能有点含糊不清。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;您可以在&lt;a href=&quot;https://cmake.org/overview/&quot;&gt;此处&lt;/a&gt;找到有关CMake的更多信息。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 配置构建系统 在前面，我们提到每个LLVM后端都有一个单独的目录LLVM/lib/Target，后端的大部分代码都在其中。 此外，LLVM依赖CMake为实际的构建系统(如Make、Ninja等)生成构建文件。 在这篇文章中，我们将仔细研究其中的一些CMake配置文件。 注意:RISCW后端代码可以在这里找到。 CMake配置文件 回想一下，RISCW后端存放在llvm/lib/Target/RISCW目录下。 该目录及其子目录都有两个构建文件(CMakeLists.txt和LLVMBuild.txt)，描述后端模块的结构，提供链接信息等。 RISCW后端目前非常简单，目录结构是这样的: llvm/lib/Target/RISCW |- CMakeLists.txt |- LLVMBuild.txt |- Other C++, TableGen, etc files |- TargetInfo/ | |- CMakeLists.txt | |- LLVMBuild.txt | |- Other C++, TableGen, etc files |- MCTargetDesc/ |- CMakeLists.txt |- LLVMBuild.txt |- Other C++, TableGen, etc files 每个使用CMake的项目都会包含CMakeLists.txt文件3，RISCW也不例外。 这些文件包含一系列CMake指令，这些指令用于驱动构建文件的生成。 在LLVM后端中，CMake会根据这些指令执行一些操作，例如指示要编译的C++源文件或生成TableGen指令。 LLVMBuild.txt文件对当前目录中包含的组件提供了描述。 LLVMBuild.txt文件 让我们看一下llvm/lib/Target/RISCW/LLVMBuild.txt的内容。 [common] subdirectories = MCTargetDesc TargetInfo [component_0] type = TargetGroup name = RISCW parent = Target has_asmprinter = 1 [component_1] type = Library name = RISCWCodeGen parent = RISCW required_libraries = AsmPrinter CodeGen Core MC RISCWDesc RISCWInfo SelectionDAG Support Target add_to_library_groups = RISCW 该文件告诉构建系统RISCW后端具有两个组件。 其中一个是顶级组件RISCW，其类型为TargetGroup，该类型表明RISCW是一个后端，构建系统对该类型有一些特殊处理。 Target是RISCW的父组件。 请注意，此命名与LLVM后端的目录结构匹配，即llvm/lib/Target/RISCW。 RISCW的名称也不是任意的，它必须与后端的TableGen文件中的定义匹配。 LLVM后端提供了一系列可选功能， 例如assembly printing，assembly parsing等， LLVMBuild.txt文件表明了后端支持哪些可选功能。 比如，最后一行告诉构建系统RISCW后端实现了assembly printing功能。 注意：查看现有后端（如ARM或RISCV）中的代码，以了解它们除了has_asmprinter之外还启用了哪些功能。 LLVMBuild.txt文件还定义了第二个名为RISCWCodeGen的组件，其类型为Library，其父级为RISCW。 另外，文件还指明了RISCWCodeGen需要的依赖库，例如AsmPrinter，CodeGen等，构建LLVM时，缺少库会导致链接错误。 llvm/lib/Target/RISCW的每个子目录也会包含一个LLVMBuild.txt文件，该文件使用RISCW作为父级来定义自己的组件。 CMakeLists.txt文件 让我们看一下llvm/lib/Target/RISCW/CMakeLists.txt文件的内容。 set(LLVM_TARGET_DEFINITIONS RISCW.td) tablegen(LLVM RISCWGenRegisterInfo.inc -gen-register-info) tablegen(LLVM RISCWGenInstrInfo.inc -gen-instr-info) # Other TableGen commands add_public_tablegen_target(RISCWCommonTableGen) # RISCWCodeGen should match with LLVMBuild.txt RISCWCodeGen add_llvm_target(RISCWCodeGen RISCWAsmPrinter.cpp # Other files ) # Should match with &quot;subdirectories = MCTargetDesc TargetInfo&quot; in LLVMBuild.txt add_subdirectory(TargetInfo) add_subdirectory(MCTargetDesc) 文件顶部的set命令将LLVM_TARGET_DEFINITION定义为`RISCW.td**。 这个文件通常包含一些顶级定义， 并通过包含其他文件的方式来引入其他TableGen定义——我们将在后面的文章中更仔细地研究TableGen， 但是请随时查看代码库中的RISCW.td。 然后我们在CMake文件中看到一些TableGen命令。 它们命令构建系统使TableGen工具根据*.td文件生成RISCWGen*.inc。 这些*.inc文件实际上就是传统的C++代码，在编译完LLVM之后，你可以在build/lib/Target/RISCW的构建目录中找到它们；它们可以用于调试，但是不容易阅读。 接下来的命令，也就是add_llvm_target， 指定了当前目录中要构建的C++文件，被指定的文件不能位于子目录中。 add_llvm_target命令的第一个参数是目标的名称，并且应该与LLVMBuild.txt中定义名称匹配。 最后，CMakeLists.txt指定了CMake应该查看的子目录，在后端RISCW中，只有两个:TargetInfo和MCTargetDesc。 子目录中的CMakeLists.txt与此类似，但要简单得多! 注意:后端文件的命名约定通常很重要，显然应该与构建文件的内容相匹配。 例如，set(LLVM_TARGET_DEFINITIONS RISCW.td)命令要求RISCW.td存在! 一定要仔细检查这些错误，因为构建错误可能有点含糊不清。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617; 您可以在此处找到有关CMake的更多信息。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(二)：创建后端</title><link href="http://localhost:4000/blog/RISCW-2.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(二)：创建后端" /><published>2020-12-06T13:30:38+08:00</published><updated>2020-12-06T13:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-2</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-2.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;创建后端&quot;&gt;创建后端&lt;/h2&gt;

&lt;p&gt;开发LLVM后端并不是一件特别吸引人的事情。
您很快就会意识到，这项工作在很大程度上就是从其他现有后端复制代码。
在线论坛上，LLVM开发者建议从“复制一个现有的后端，重命名并修改它以适应您的需要”开。
但是即使是相对较小的后端，比如Lanai或XCore，也相当复杂，而且代码也不容易理解！&lt;/p&gt;

&lt;p&gt;在本系列文章中，将采取略有不同的方法。
我们将使用现有的LLVM后端作为起点，但我已经删除了大部分代码，并将其减少到编译一个(很小的)程序所需的最低限度。
精简的后端，称为RISCW，非常简单，可以帮助理解LLVM目标独立代码生成器，而不必纠缠于细节。
在这篇文章的其余部分，我将使用RISCW后端来展示如何创建一个新的LLVM后端。
我们还将看到如何用一个实验性的后端构建LLVM，甚至编译一个(非常简单的) C程序到汇编。&lt;/p&gt;

&lt;h3 id=&quot;triple和elf配置&quot;&gt;Triple和ELF配置&lt;/h3&gt;

&lt;p&gt;我们首先为后端配置一个新的目标描述Triple。
由于历史原因，Triple编码了目标平台的重要信息（如体系结构、供应商和操作系统）。
以下是配置一个新的Triple的步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在llvm/include/llvm/ADT/Triple.h用Triple声明一个新的体系结构 (见这里)。&lt;/li&gt;
  &lt;li&gt;提供字符串和Triple之间的类型转换(参见这里,这里及这里)。&lt;/li&gt;
  &lt;li&gt;指出后端支持的目标文件类型，例如ELF、COFF等，ricw只支持ELF(参见这里)。&lt;/li&gt;
  &lt;li&gt;指出目标平台的字平台，例如32位或64位，以及指针的大小(请参阅这里,这里及这里)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;你可以在这里和这里找到更多关于Triple的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;指令集并不一定意味着指针的大小。
例如，在为RV64编译时，指针并不总是64位的。
指针大小通常由ABI给出，在64位机器中，它可以是ilp32(即int、long和指针为32位)。&lt;/p&gt;

&lt;p&gt;下面的参数用于配置ELF:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个枚举值作为RISCW的体系结构的标识(见此处)。
这个值被编码在ELF文件头的e_machine字段中。
这个值不是随意设置的; 它必须取得授权，例如:0xF3 for RISCV。
但是我们现在将它设置为一个未使用的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明ELF重定位类型(见这里和这里)。
同样，这些是依赖于架构的，这里列出了用于RISCV的类型。
在这个阶段，我们将简单地为RISCW放置了占位符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件格式名称(见此处)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指示给定类的目标描述Triple(见此处)。目前，ELF头中的类是一个字节，用于对格式是32位还是64位进行编码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;查看wikipedia获取更多关于ELF文件的信息。&lt;/p&gt;

&lt;h3 id=&quot;配置驱动器&quot;&gt;配置驱动器&lt;/h3&gt;

&lt;p&gt;回想一下，我们使用clang将输入的C代码编译成LLVM IR。
但是clang不仅仅是我们的编译器前端，它也是一个驱动器，类似GCC，驱动编译流水线将输入的C程序转换为另一个表示，比如把C转换为汇编或目标代码。
因此，我们需要告诉clang&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新后端的支持特性。例如，clang需要知道RISCW是32位还是64位。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新后端的编译流程。例如，它应该使用什么汇编程序? 什么连接器? 有哪些包括路径等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过添加一个新的target类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;来告诉clang有关RISCW的信息，该类与LLVM已有的target类一起被实例化，如这里所示。
该类在这里和这里分别被声明和定义。
在这段代码中有一些重要的事情需要强调:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;通过字符串描述数据布局。这个字符串编码许多重要信息，比如指针中每一位、堆栈对齐要求等。&lt;/li&gt;
  &lt;li&gt;基本C数据类型的大小。&lt;/li&gt;
  &lt;li&gt;函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo::getTargetDefines(**&lt;/code&gt;指示编译时定义的C预处理器宏，例如，这些宏是在使用RISCV后端编译代码时定义的。
宏通常描述后端支持的体系结构、ABI、启用/禁用任何特性等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;一个后端可能支持多个指令集和ABI，因此驱动器的配置必须根据选定的目标Triple进行更改。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;根据Triple包含riscv32还是riscv64来更改数据布局字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;这里可以查看RISCWTargetInfo的父类TargetInfo的声明。
它包含了更多的可以配置的选项。&lt;/p&gt;

&lt;p&gt;配置工具链相对简单。
我们只需要实现一个从Toolchain继承的RISCWToolChain类，如下所示。
代码基本上是不言自明的，通过覆盖ToolChain类的成员，您可以修改更多的选项(见此处)。&lt;/p&gt;

&lt;h3 id=&quot;创建新target&quot;&gt;创建新Target&lt;/h3&gt;

&lt;p&gt;每个后端在llvm/lib/Target下都有一个单独的目录，其中包含后端的大部分代码。
我们不会在这篇文章中深入讨论代码的细节(稍后我们会这样做) ，因为即使是一个很小的后端，比如RISCW，也有很多文件。
目前，我们可以将这些文件大致分为三类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TableGen文件&lt;/strong&gt;LLVM目标无关代码生成框架实现了一个精心设计的模式匹配算法，用于为输入的程序选择指令。
待匹配的模式使用TableGen语法描述。
此外，TableGen文件还描述了target在体系结构方面的重要特性，如寄存器的数量和调用约定等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Build文件&lt;/strong&gt;后端的每个目录都必须被声明，否则它将不会被构建。
此外，我们的后端的顶部目录(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;) ，以及每个子目录必须包含两个构建文件:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;，
前者将源文件和任何子目录添加为生成目标，而后者为生成目标设置简单的生成参数，参数包括生成目标的名称、链接所需的库等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;C++文件&lt;/strong&gt;包含了大量的后端代码，实现了从简单的配置选项到更复杂的指令选择功能(TableGen没有实现或不能实现)的所有功能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;建立实验性后端&quot;&gt;建立实验性后端&lt;/h3&gt;

&lt;p&gt;现在，一切都已经建立，我们可以构建带有RISCW后端的LLVM。
但是我们不能简单地根据上一章的内容修改CMake的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/code&gt;选项，以包含RISCW，因为后端仍处于试验阶段。
相反，我们使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&lt;/code&gt;选项，如下:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ninja&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clang&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM;Lanai;RISCV&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;RISCW&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Debug&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_ASSERTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;On ../llvm
ninja
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当构建完成后，你可以检查RISCW现在是否是一个可用的后端，如下所示:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./build/bin/llc &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
LLVM &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;http://llvm.org/&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
  LLVM version 10.0.1
  DEBUG build with assertions.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: znver2

  Registered Targets:
    arm     - ARM
    armeb   - ARM &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;big endian&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    lanai   - Lanai
    riscv32 - 32-bit RISC-V
    riscv64 - 64-bit RISC-V
    riscw   - 32-bit RISC-V         &amp;lt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; YAY!!
    thumb   - Thumb
    thumbeb - Thumb &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;big endian&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;编译c程序&quot;&gt;编译C程序&lt;/h3&gt;
&lt;p&gt;我们的RISCW后端只能发出两条add和ret指令，而且它不能正确处理函数调用、堆栈和几乎所有其他的东西！
因此，我们将约束自己，只编译这个小函数:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int a, int b&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;a + b&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就这样，我们得到了这样一个代码:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	.text
	.file	&lt;span class=&quot;s2&quot;&gt;&quot;test.c&quot;&lt;/span&gt;
	.globl	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;                    &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Begin &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
	.type	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;,@function
&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;:                                   &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; @test
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; %bb.0:                                &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; %entry
	add	x0, x1, x0
	ret
.Lfunc_end0:
	.size	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;, .Lfunc_end0-test
                                        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; End &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;
	.ident	&lt;span class=&quot;s2&quot;&gt;&quot;clang version 10.0.1 (https://github.com/llvm/llvm-project 89f2d2cc3bba7cb12cee346b3205cb0335e758cd)&quot;&lt;/span&gt;
	.section	&lt;span class=&quot;s2&quot;&gt;&quot;.note.GNU-stack&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;,@progbits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有很多东西缺失了，代码实际上是不正确的，在RISCV中的x0是一个硬编码为0的只读寄存器。
但是我认为我们已经达到了目标: 建立了一个最小的LLVM后端，可以很容易地用更多的特性进行扩展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;如果您使用上一篇文章中的命令来编译上面的测试函数，请确保为clang设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-target riscw&lt;/code&gt;和为llc设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=riscw&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;试图编译更复杂的程序将导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cannot select...&lt;/code&gt;错误。如果你感兴趣，就试一试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;您可以通过将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-debug&lt;/code&gt;选项传递给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llc&lt;/code&gt;来指示编译器打印调试信息。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 创建后端 开发LLVM后端并不是一件特别吸引人的事情。 您很快就会意识到，这项工作在很大程度上就是从其他现有后端复制代码。 在线论坛上，LLVM开发者建议从“复制一个现有的后端，重命名并修改它以适应您的需要”开。 但是即使是相对较小的后端，比如Lanai或XCore，也相当复杂，而且代码也不容易理解！ 在本系列文章中，将采取略有不同的方法。 我们将使用现有的LLVM后端作为起点，但我已经删除了大部分代码，并将其减少到编译一个(很小的)程序所需的最低限度。 精简的后端，称为RISCW，非常简单，可以帮助理解LLVM目标独立代码生成器，而不必纠缠于细节。 在这篇文章的其余部分，我将使用RISCW后端来展示如何创建一个新的LLVM后端。 我们还将看到如何用一个实验性的后端构建LLVM，甚至编译一个(非常简单的) C程序到汇编。 Triple和ELF配置 我们首先为后端配置一个新的目标描述Triple。 由于历史原因，Triple编码了目标平台的重要信息（如体系结构、供应商和操作系统）。 以下是配置一个新的Triple的步骤: 在llvm/include/llvm/ADT/Triple.h用Triple声明一个新的体系结构 (见这里)。 提供字符串和Triple之间的类型转换(参见这里,这里及这里)。 指出后端支持的目标文件类型，例如ELF、COFF等，ricw只支持ELF(参见这里)。 指出目标平台的字平台，例如32位或64位，以及指针的大小(请参阅这里,这里及这里)。 注意:你可以在这里和这里找到更多关于Triple的信息。 注意:指令集并不一定意味着指针的大小。 例如，在为RV64编译时，指针并不总是64位的。 指针大小通常由ABI给出，在64位机器中，它可以是ilp32(即int、long和指针为32位)。 下面的参数用于配置ELF: 创建一个枚举值作为RISCW的体系结构的标识(见此处)。 这个值被编码在ELF文件头的e_machine字段中。 这个值不是随意设置的; 它必须取得授权，例如:0xF3 for RISCV。 但是我们现在将它设置为一个未使用的值。 声明ELF重定位类型(见这里和这里)。 同样，这些是依赖于架构的，这里列出了用于RISCV的类型。 在这个阶段，我们将简单地为RISCW放置了占位符。 文件格式名称(见此处)。 指示给定类的目标描述Triple(见此处)。目前，ELF头中的类是一个字节，用于对格式是32位还是64位进行编码。 注意:查看wikipedia获取更多关于ELF文件的信息。 配置驱动器 回想一下，我们使用clang将输入的C代码编译成LLVM IR。 但是clang不仅仅是我们的编译器前端，它也是一个驱动器，类似GCC，驱动编译流水线将输入的C程序转换为另一个表示，比如把C转换为汇编或目标代码。 因此，我们需要告诉clang 新后端的支持特性。例如，clang需要知道RISCW是32位还是64位。 新后端的编译流程。例如，它应该使用什么汇编程序? 什么连接器? 有哪些包括路径等等。 我们可以通过添加一个新的target类RISCWTargetInfo来告诉clang有关RISCW的信息，该类与LLVM已有的target类一起被实例化，如这里所示。 该类在这里和这里分别被声明和定义。 在这段代码中有一些重要的事情需要强调: RISCWTargetInfo通过字符串描述数据布局。这个字符串编码许多重要信息，比如指针中每一位、堆栈对齐要求等。 基本C数据类型的大小。 函数RISCWTargetInfo::getTargetDefines(**指示编译时定义的C预处理器宏，例如，这些宏是在使用RISCV后端编译代码时定义的。 宏通常描述后端支持的体系结构、ABI、启用/禁用任何特性等 注意:一个后端可能支持多个指令集和ABI，因此驱动器的配置必须根据选定的目标Triple进行更改。 例如，RISCWTargetInfo根据Triple包含riscv32还是riscv64来更改数据布局字符串。 注意:这里可以查看RISCWTargetInfo的父类TargetInfo的声明。 它包含了更多的可以配置的选项。 配置工具链相对简单。 我们只需要实现一个从Toolchain继承的RISCWToolChain类，如下所示。 代码基本上是不言自明的，通过覆盖ToolChain类的成员，您可以修改更多的选项(见此处)。 创建新Target 每个后端在llvm/lib/Target下都有一个单独的目录，其中包含后端的大部分代码。 我们不会在这篇文章中深入讨论代码的细节(稍后我们会这样做) ，因为即使是一个很小的后端，比如RISCW，也有很多文件。 目前，我们可以将这些文件大致分为三类: TableGen文件LLVM目标无关代码生成框架实现了一个精心设计的模式匹配算法，用于为输入的程序选择指令。 待匹配的模式使用TableGen语法描述。 此外，TableGen文件还描述了target在体系结构方面的重要特性，如寄存器的数量和调用约定等。 Build文件后端的每个目录都必须被声明，否则它将不会被构建。 此外，我们的后端的顶部目录(llvm/lib/Target/RISCW) ，以及每个子目录必须包含两个构建文件:CMakeLists.txt和LLVMBuild.txt， 前者将源文件和任何子目录添加为生成目标，而后者为生成目标设置简单的生成参数，参数包括生成目标的名称、链接所需的库等。 C++文件包含了大量的后端代码，实现了从简单的配置选项到更复杂的指令选择功能(TableGen没有实现或不能实现)的所有功能。 建立实验性后端 现在，一切都已经建立，我们可以构建带有RISCW后端的LLVM。 但是我们不能简单地根据上一章的内容修改CMake的-DLLVM_TARGETS_TO_BUILD选项，以包含RISCW，因为后端仍处于试验阶段。 相反，我们使用-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD选项，如下: cmake -G &quot;Ninja&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_TARGETS_TO_BUILD=&quot;ARM;Lanai;RISCV&quot; -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=&quot;RISCW&quot; -DCMAKE_BUILD_TYPE=&quot;Debug&quot; -DLLVM_ENABLE_ASSERTIONS=On ../llvm ninja 当构建完成后，你可以检查RISCW现在是否是一个可用的后端，如下所示: $ ./build/bin/llc --version LLVM (http://llvm.org/): LLVM version 10.0.1 DEBUG build with assertions. Default target: x86_64-unknown-linux-gnu Host CPU: znver2 Registered Targets: arm - ARM armeb - ARM (big endian) lanai - Lanai riscv32 - 32-bit RISC-V riscv64 - 64-bit RISC-V riscw - 32-bit RISC-V &amp;lt;== YAY!! thumb - Thumb thumbeb - Thumb (big endian) 编译C程序 我们的RISCW后端只能发出两条add和ret指令，而且它不能正确处理函数调用、堆栈和几乎所有其他的东西！ 因此，我们将约束自己，只编译这个小函数: int test(int a, int b) { return a + b; } 就这样，我们得到了这样一个代码: .text .file &quot;test.c&quot; .globl test ; -- Begin function test .type test,@function test: ; @test ; %bb.0: ; %entry add x0, x1, x0 ret .Lfunc_end0: .size test, .Lfunc_end0-test ; -- End function .ident &quot;clang version 10.0.1 (https://github.com/llvm/llvm-project 89f2d2cc3bba7cb12cee346b3205cb0335e758cd)&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits 有很多东西缺失了，代码实际上是不正确的，在RISCV中的x0是一个硬编码为0的只读寄存器。 但是我认为我们已经达到了目标: 建立了一个最小的LLVM后端，可以很容易地用更多的特性进行扩展。 注意:如果您使用上一篇文章中的命令来编译上面的测试函数，请确保为clang设置了-target riscw和为llc设置了-march=riscw。 注意:试图编译更复杂的程序将导致cannot select...错误。如果你感兴趣，就试一试。 注意:您可以通过将-debug选项传递给llc来指示编译器打印调试信息。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(一)：入门</title><link href="http://localhost:4000/blog/RISCW-1.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(一)：入门" /><published>2020-12-04T19:30:38+08:00</published><updated>2020-12-04T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-1</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-1.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;

&lt;p&gt;在为新项目编写代码之前，我通常会配置环境，并对查看经存在的代码，这就是这一节要做的。在这一节中，我将展示如何下载编译LLVM和其他对调试有用的工具。我们还将了解如何使用现有的LLVM后端和GNU工具链来编译、汇编、链接和运行程序。&lt;/p&gt;

&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;

&lt;p&gt;我正在使用Ubuntu，但是你应该能够在其他系统中重复这些步骤，而且(相对来说)几乎没有什么不同。您将需要以下工具来构建软件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Makefile&lt;/li&gt;
  &lt;li&gt;C/C++ Compiler – 我用 GCC 9.2.1&lt;/li&gt;
  &lt;li&gt;autotools&lt;/li&gt;
  &lt;li&gt;CMake&lt;/li&gt;
  &lt;li&gt;Ninja&lt;/li&gt;
  &lt;li&gt;Git&lt;/li&gt;
  &lt;li&gt;大量耐心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;我可能忘记了一些东西，但是构建系统会通过一个错误告诉您；&lt;/p&gt;

&lt;h3 id=&quot;编译llvm&quot;&gt;编译LLVM&lt;/h3&gt;

&lt;p&gt;LLVM维护者已经建立了这个方便的repo，它包含LLVM和工具链的其他部分，比如Clang。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/llvm/llvm-project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在本系列文章中，我们将使用llvm 10.0.1，我建议您也使用该版本的LLVM。
因为LLVM的变化非常快，这里显示的一些代码在旧/新版本中可能无法工作。
不过，原理应该大致相同。&lt;/p&gt;

&lt;p&gt;LLVM使用CMake为构建系统生成构建文件，LLVM支持的构建系有：Ninja，Makefiles，Visual Studio和XCode。
我通常使用Ninja，因为我认为它在我的系统中速度最快（我没有证据支持该判断！）。
您可以通过cmake命令的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-G&lt;/code&gt;参数来更改构建系统。&lt;/p&gt;

&lt;p&gt;CMake有很多选项，我鼓励您对其进行研究，因为有些选项对调试非常有帮助。
您可以在&lt;a href=&quot;https://llvm.org/docs/CMake.html&quot;&gt;这里&lt;/a&gt;阅读所有构建选项。
在本教程中，我将使用以下选项:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/code&gt; 构建编译器的其余部分，比如Clang。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/code&gt; 指定要构建的后端。查看其他后端的输出对调试很有帮助，但是如果添加太多，构建会花费很长时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/code&gt; 构建Debug版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_ENABLE_ASSERTIONS=On&lt;/code&gt; 启用断言，对调试很有帮助。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是在克隆repo之后构建LLVM的方法。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;llvm-project
git checkout llvmorg-10.0.1
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
cmake &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ninja&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clang&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM;Lanai;RISCV&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Debug&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_ASSERTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;On ../llvm
ninja
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以在&lt;a href=&quot;https://llvm.org/docs/GettingStarted.html&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://llvm.org/docs/CMake.html&quot;&gt;这里&lt;/a&gt;找到更多有关构建LLVM的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以为Ninja传递&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-j &amp;lt;NUM_JOBS&amp;gt;&lt;/code&gt;选项，以指示要并行的作业数。 
过高的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;NUM_JOBS&amp;gt;&lt;/code&gt;会导致构建崩溃，并产生&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect2：ld ...&lt;/code&gt;错误消息。&lt;/p&gt;

&lt;h3 id=&quot;编译risc-v的gnu工具链&quot;&gt;编译RISC V的GNU工具链&lt;/h3&gt;

&lt;p&gt;你可能有点困惑，为什么我建议构建GCC的RISC V后端？
难道我们不是要自己编写编译器后端吗？&lt;/p&gt;

&lt;p&gt;我们构建GCC的RISC V后端，是因为我们希望在初始阶段使用GCC的汇编器和链接器来测试LLVM后端生成的代码。
编译过程分为很多阶段，在初始阶段，我们已经有以下结构:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clang 编译C代码到LLVM IR&lt;/li&gt;
  &lt;li&gt;LLVM 优化IR&lt;/li&gt;
  &lt;li&gt;LLVM后端 编译IR到汇编&lt;/li&gt;
  &lt;li&gt;GCC 汇编和链接可执行文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用以下命令下载，构建和安装GCC for RISCV。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/riscv/riscv-gnu-toolchain
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;riscv-gnu-toolchain
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
../configure &lt;span class=&quot;nt&quot;&gt;--with-arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;rv32gc &lt;span class=&quot;nt&quot;&gt;--with-abi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ilp32
make
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;请确保为指令集的正确变体（即RV32）构建GCC工具链，因为构建系统的默认值为RV64！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;GNU工具链支持RISC V的多个ABI，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32d&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32f&lt;/code&gt;，这取决于您是否需要软浮点，硬浮点。&lt;/p&gt;

&lt;h3 id=&quot;编译c程序&quot;&gt;编译C程序&lt;/h3&gt;

&lt;p&gt;现在，构建和运行C代码的环境已经配置好了，尽管我们还没自己的后端（还！）。让我们从一个简单的C程序开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，使用Clang将C代码编译为LLVM IR。
我们的计划是使用标准库中来自头文件stdio.h的函数printf，如果不能找到头文件，编译器会提示出错。
为了使用GCC自带的RISC V标准C库，我们使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-isystem&lt;/code&gt;参数。
这会将包含所需头文件的目录添加到Clang预处理器的搜索目录列表中。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang &lt;span class=&quot;nt&quot;&gt;-O2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-emit-llvm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-target&lt;/span&gt; riscv64 &lt;span class=&quot;nt&quot;&gt;-isystem&lt;/span&gt; &amp;lt;PATH_TO_GCC&amp;gt;/riscv64-unknown-elf/include &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test.c &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.bc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的命令把C语言文件test.c编译到LLVM IR文件test.bc，这是专门为机器设计的语言人类很难直接阅读。
我们可以使用以下命令反汇编该文件：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm-dis test.bc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在，使用包含以下内容的后端将IR编译为程序集，而无需使用以下命令下载LLVM：
现在，使用LLVM自带的后端将IR编译为程汇编：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llc &lt;span class=&quot;nt&quot;&gt;-march&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;riscv64 &lt;span class=&quot;nt&quot;&gt;-O2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-filetype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;asm test.bc &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.S
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;GCC可以直接生成程序的二进制文件。
我将其分为两个步骤，但是您可以根据需要使用单个命令。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;riscv64-unknown-elf-gcc &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test.S &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.o
riscv64-unknown-elf-gcc test.o &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后，我们可以使用模拟器或真实硬件运行程序。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 入门 在为新项目编写代码之前，我通常会配置环境，并对查看经存在的代码，这就是这一节要做的。在这一节中，我将展示如何下载编译LLVM和其他对调试有用的工具。我们还将了解如何使用现有的LLVM后端和GNU工具链来编译、汇编、链接和运行程序。 环境 我正在使用Ubuntu，但是你应该能够在其他系统中重复这些步骤，而且(相对来说)几乎没有什么不同。您将需要以下工具来构建软件。 Makefile C/C++ Compiler – 我用 GCC 9.2.1 autotools CMake Ninja Git 大量耐心 注意：我可能忘记了一些东西，但是构建系统会通过一个错误告诉您； 编译LLVM LLVM维护者已经建立了这个方便的repo，它包含LLVM和工具链的其他部分，比如Clang。 git clone https://github.com/llvm/llvm-project 在本系列文章中，我们将使用llvm 10.0.1，我建议您也使用该版本的LLVM。 因为LLVM的变化非常快，这里显示的一些代码在旧/新版本中可能无法工作。 不过，原理应该大致相同。 LLVM使用CMake为构建系统生成构建文件，LLVM支持的构建系有：Ninja，Makefiles，Visual Studio和XCode。 我通常使用Ninja，因为我认为它在我的系统中速度最快（我没有证据支持该判断！）。 您可以通过cmake命令的-G参数来更改构建系统。 CMake有很多选项，我鼓励您对其进行研究，因为有些选项对调试非常有帮助。 您可以在这里阅读所有构建选项。 在本教程中，我将使用以下选项: -DLLVM_ENABLE_PROJECTS 构建编译器的其余部分，比如Clang。 -DLLVM_TARGETS_TO_BUILD 指定要构建的后端。查看其他后端的输出对调试很有帮助，但是如果添加太多，构建会花费很长时间。 -DCMAKE_BUILD_TYPE 构建Debug版本。 -DLLVM_ENABLE_ASSERTIONS=On 启用断言，对调试很有帮助。 以下是在克隆repo之后构建LLVM的方法。 cd llvm-project git checkout llvmorg-10.0.1 mkdir build cd build cmake -G &quot;Ninja&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_TARGETS_TO_BUILD=&quot;ARM;Lanai;RISCV&quot; -DCMAKE_BUILD_TYPE=&quot;Debug&quot; -DLLVM_ENABLE_ASSERTIONS=On ../llvm ninja 注意：您可以在这里和这里找到更多有关构建LLVM的信息。 注意：您可以为Ninja传递-j &amp;lt;NUM_JOBS&amp;gt;选项，以指示要并行的作业数。 过高的&amp;lt;NUM_JOBS&amp;gt;会导致构建崩溃，并产生collect2：ld ...错误消息。 编译RISC V的GNU工具链 你可能有点困惑，为什么我建议构建GCC的RISC V后端？ 难道我们不是要自己编写编译器后端吗？ 我们构建GCC的RISC V后端，是因为我们希望在初始阶段使用GCC的汇编器和链接器来测试LLVM后端生成的代码。 编译过程分为很多阶段，在初始阶段，我们已经有以下结构: Clang 编译C代码到LLVM IR LLVM 优化IR LLVM后端 编译IR到汇编 GCC 汇编和链接可执行文件 使用以下命令下载，构建和安装GCC for RISCV。 git clone https://github.com/riscv/riscv-gnu-toolchain cd riscv-gnu-toolchain mkdir build cd build ../configure --with-arch=rv32gc --with-abi=ilp32 make make install 注意：请确保为指令集的正确变体（即RV32）构建GCC工具链，因为构建系统的默认值为RV64！ 注意：GNU工具链支持RISC V的多个ABI，例如ilp32，ilp32d和ilp32f，这取决于您是否需要软浮点，硬浮点。 编译C程序 现在，构建和运行C代码的环境已经配置好了，尽管我们还没自己的后端（还！）。让我们从一个简单的C程序开始： #include &amp;lt;stdio.h&amp;gt; int main(void) { printf(&quot;Hello world!\n&quot;); return 0; } 首先，使用Clang将C代码编译为LLVM IR。 我们的计划是使用标准库中来自头文件stdio.h的函数printf，如果不能找到头文件，编译器会提示出错。 为了使用GCC自带的RISC V标准C库，我们使用了-isystem参数。 这会将包含所需头文件的目录添加到Clang预处理器的搜索目录列表中。 clang -O2 -emit-llvm -target riscv64 -isystem &amp;lt;PATH_TO_GCC&amp;gt;/riscv64-unknown-elf/include -c test.c -o test.bc 上面的命令把C语言文件test.c编译到LLVM IR文件test.bc，这是专门为机器设计的语言人类很难直接阅读。 我们可以使用以下命令反汇编该文件： llvm-dis test.bc 现在，使用包含以下内容的后端将IR编译为程序集，而无需使用以下命令下载LLVM： 现在，使用LLVM自带的后端将IR编译为程汇编： llc -march=riscv64 -O2 -filetype=asm test.bc -o test.S GCC可以直接生成程序的二进制文件。 我将其分为两个步骤，但是您可以根据需要使用单个命令。 riscv64-unknown-elf-gcc -c test.S -o test.o riscv64-unknown-elf-gcc test.o -o test 最后，我们可以使用模拟器或真实硬件运行程序。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(零)：简介</title><link href="http://localhost:4000/blog/RISCW-0.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(零)：简介" /><published>2020-12-03T19:30:38+08:00</published><updated>2020-12-03T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-0</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-0.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;在本教程中，我将为RISC V指令集的基本32位版本（即RV32IM）开发一个后端。希望这能帮助那些不熟悉LLVM的人开始使用这个工具，并将其扩展到自己的项目中。看懂本教程不需要前置知识，但是如果你熟悉C++和RISC V，学习本教程会更容易。&lt;/p&gt;

&lt;p&gt;在本文剩下的部分中，我将简要描述LLVM的体系结构和后端结构。不过，我不会在这里详细说明，因为，如果你像我一样，在5分钟（或5秒）之后，就会忘记读过的任何繁琐文档。LLVM的细节将在以后的帖子中根据需要提供。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;如果你想要更详细的版本，你可以自娱自乐地阅读&lt;a href=&quot;http://llvm.org/docs/UserGuides.html&quot;&gt;LLVM User Guides&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;llvm架构&quot;&gt;LLVM架构&lt;/h3&gt;

&lt;p&gt;传统上，编译过程分为三个阶段。
首先，编译器的前端将源代码转换为某种中间表示（IR）；
然后，优化IR；
最后，编译器的后端将IR转换为机器代码。
传统的编译器通常仅支持一种编程语言和一种目标指令集，编译器的源代码很难重用，例如添加新的目标指令集。&lt;/p&gt;

&lt;p&gt;LLVM模块化地实现了三个编译过程，可以解决重用问题。
其思想是LLVM的核心（即IR和优化器）是固定的，但是前端和后端可以被替换，以使编译器可以支持多种编程语言和指令集。
例如，我们可以使用Clang（LLVM的前端）和x86后端把C/C++代码编译成X86指令集上的可执行程序。
我们也可以用ARM后端替换X86后端，从而得到ARM指令集上的可执行程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;LLVM的设计师Chris Lattner撰写了这篇&lt;a href=&quot;http://www.aosabook.org/en/llvm.html&quot;&gt;文章&lt;/a&gt;介绍LLVM的体系结构及其设计动机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;LLVM的这三个阶段的每个阶段在都有一个专用的可执行文件。
clang是C/C++的前端（显然针对不同的编程语言有不同的前端），opt是优化程序，llc用于调用后端。
通常，我们使用clang作为驱动程序来执行前端，使用llc和opt配合适当的参数来生成IR，汇编，可执行文件等。&lt;/p&gt;

&lt;h3 id=&quot;代码生成&quot;&gt;代码生成&lt;/h3&gt;
&lt;p&gt;LLVM后端将IR编译为目标代码或汇编代码。
每个后端都只支持单一平台，但可以支持多个指令集。
例如，LLVM只有一个ARM后端，但该后端可以为ARMv6和ARMv7等指令集生成代码。
每个后端都建立在LLVM的目标无关代码生成器之上。
目标无关代码生成器是一个框架，可实现诸如寄存器分配之类的关键算法。
从广义上讲，后端的任务是配置该框架并使之适应其目标指令集的特定需求。&lt;/p&gt;

&lt;p&gt;代码生成具有以下阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;指令选择&lt;/strong&gt; 映射LLVM IR到目标指令集中的指令。
此阶段使用无限数量的虚拟寄存器和函数调用堆栈的抽象引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;计划和编排&lt;/strong&gt; 确定指令的顺序。
需要明确的是，在指令选择阶段已经对指令进行了排序，但这里可以根据寄存器分配策略或指令等待时间来对其中的一些指令的排序进行优化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;基于SSA的机器代码优化&lt;/strong&gt; 执行诸如&lt;a href=&quot;https://en.wikipedia.org/wiki/Peephole_optimization&quot;&gt;peephole&lt;/a&gt;优化之类的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;寄存器分配&lt;/strong&gt; 将虚拟寄存器映射到物理寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prolog / Epilog插入&lt;/strong&gt; 在每个函数的开头（或prolog）和结尾（或epilog）插入机器指令。
这些通常是在进入或退出函数时扩展堆栈的指令。
由于当前已经知道堆栈大小，因此也可以解析抽象堆栈引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;后期机器代码优化&lt;/strong&gt; 可能不言自明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;代码发射&lt;/strong&gt; 发出目标代码或汇编代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，我将看一下构建LLVM以及如何设置开发/调试环境…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以阅读&lt;a href=&quot;http://llvm.org/docs/CodeGenerator.html&quot;&gt;这篇文章&lt;/a&gt;了解LLVM目标无关代码生成器的更多信息。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 简介 在本教程中，我将为RISC V指令集的基本32位版本（即RV32IM）开发一个后端。希望这能帮助那些不熟悉LLVM的人开始使用这个工具，并将其扩展到自己的项目中。看懂本教程不需要前置知识，但是如果你熟悉C++和RISC V，学习本教程会更容易。 在本文剩下的部分中，我将简要描述LLVM的体系结构和后端结构。不过，我不会在这里详细说明，因为，如果你像我一样，在5分钟（或5秒）之后，就会忘记读过的任何繁琐文档。LLVM的细节将在以后的帖子中根据需要提供。 注意:如果你想要更详细的版本，你可以自娱自乐地阅读LLVM User Guides。 LLVM架构 传统上，编译过程分为三个阶段。 首先，编译器的前端将源代码转换为某种中间表示（IR）； 然后，优化IR； 最后，编译器的后端将IR转换为机器代码。 传统的编译器通常仅支持一种编程语言和一种目标指令集，编译器的源代码很难重用，例如添加新的目标指令集。 LLVM模块化地实现了三个编译过程，可以解决重用问题。 其思想是LLVM的核心（即IR和优化器）是固定的，但是前端和后端可以被替换，以使编译器可以支持多种编程语言和指令集。 例如，我们可以使用Clang（LLVM的前端）和x86后端把C/C++代码编译成X86指令集上的可执行程序。 我们也可以用ARM后端替换X86后端，从而得到ARM指令集上的可执行程序。 注意：LLVM的设计师Chris Lattner撰写了这篇文章介绍LLVM的体系结构及其设计动机。 注意：LLVM的这三个阶段的每个阶段在都有一个专用的可执行文件。 clang是C/C++的前端（显然针对不同的编程语言有不同的前端），opt是优化程序，llc用于调用后端。 通常，我们使用clang作为驱动程序来执行前端，使用llc和opt配合适当的参数来生成IR，汇编，可执行文件等。 代码生成 LLVM后端将IR编译为目标代码或汇编代码。 每个后端都只支持单一平台，但可以支持多个指令集。 例如，LLVM只有一个ARM后端，但该后端可以为ARMv6和ARMv7等指令集生成代码。 每个后端都建立在LLVM的目标无关代码生成器之上。 目标无关代码生成器是一个框架，可实现诸如寄存器分配之类的关键算法。 从广义上讲，后端的任务是配置该框架并使之适应其目标指令集的特定需求。 代码生成具有以下阶段： 指令选择 映射LLVM IR到目标指令集中的指令。 此阶段使用无限数量的虚拟寄存器和函数调用堆栈的抽象引用。 计划和编排 确定指令的顺序。 需要明确的是，在指令选择阶段已经对指令进行了排序，但这里可以根据寄存器分配策略或指令等待时间来对其中的一些指令的排序进行优化。 基于SSA的机器代码优化 执行诸如peephole优化之类的工作。 寄存器分配 将虚拟寄存器映射到物理寄存器。 Prolog / Epilog插入 在每个函数的开头（或prolog）和结尾（或epilog）插入机器指令。 这些通常是在进入或退出函数时扩展堆栈的指令。 由于当前已经知道堆栈大小，因此也可以解析抽象堆栈引用。 后期机器代码优化 可能不言自明。 代码发射 发出目标代码或汇编代码。 接下来，我将看一下构建LLVM以及如何设置开发/调试环境… 注意：您可以阅读这篇文章了解LLVM目标无关代码生成器的更多信息。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/blog/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2020-12-03T18:38:38+08:00</published><updated>2020-12-03T18:38:38+08:00</updated><id>http://localhost:4000/blog/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/blog/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. Jekyll requires blog post files to be named according to the following format: YEAR-MONTH-DAY-title.MARKUP Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: def print_hi(name) puts &quot;Hi, #{name}&quot; end print_hi('Tom') #=&amp;gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.</summary></entry></feed>