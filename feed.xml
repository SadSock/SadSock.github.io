<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-10T15:44:48+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">悲催的袜子</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">为LLVM添加简易RISCV后端(五)：指令选择</title><link href="http://localhost:4000/blog/RISCW-5.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(五)：指令选择" /><published>2020-12-08T19:30:38+08:00</published><updated>2020-12-08T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-5</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-5.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;指令选择&quot;&gt;指令选择&lt;/h2&gt;

&lt;p&gt;我们先前简要介绍了LLVM后端的工作过程。
在这篇文章中，我们将更深入地了解这个过程的第一个阶段：指令选择。
我们的目的是在了解RISCW后端的具体实现之前，了解它的工作原理以及如何配置它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;a href=&quot;https://llvm.org/docs/CodeGenerator.html#instruction-selection-section&quot;&gt;LLVM文档&lt;/a&gt;对指令选择的工作原理给出了简短而清晰的描述，
这篇文章通过示例来重新说明这一点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文中显示的示例是使用我们的RISCW后端框架构建的。可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/commit/274cfea0f9662f0ed49f6132b0424323d0b11750&quot;&gt;这里&lt;/a&gt;找到它的来源。&lt;/p&gt;

&lt;p&gt;指令选择过程将LLVM IR转化为指令序列，该指令序列使用了无穷数量的寄存器。
该过程分为以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;构建初始DAG&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;类型合法化&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;操作合法化&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
  &lt;li&gt;目标指令选择&lt;/li&gt;
  &lt;li&gt;调度和形成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我觉得通过例子来了解发生的事情会比较容易，我们将考虑指令选择如何转换下面的C程序。
该代码包含一个MUL函数，该函数接受64位参数x和32位参数y。
参数相乘，并返回32位整数结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;unsigned int MUL(unsigned long long int x, unsigned int y)
{
    return x * y;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;构建dag&quot;&gt;构建DAG&lt;/h3&gt;

&lt;p&gt;这是指令选择的第一阶段。
它接受LLVM IR作为输入，
并产生Selection DAG(有向无环图)作为输出。
指令选择过程中的每个其他阶段都在DAG上执行，直到产生输出指令序列。
正如前面几篇文章所讨论的，LLVM IR是前端工具(如Clang)根据C代码生成，随后由LLVM优化器进行优化。
下面是C程序的LLVM IR:&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dso_local&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@MUL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;local_unnamed_addr&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;entry:&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;trunc&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i64&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%conv1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mul&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%y&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%conv1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Selection DAG实际上是一种精巧的树型数据结构，它表示LLVM IR中的基本块。 
基本块是不包含分支目的地（入口除外）和分支指令（出口除外）的指令序列。 
示例MUL函数非常简单，它只有一个称为入口的基本块，其他函数通常具有多个基本块。 
例如，下面的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello&lt;/code&gt;函数具有四个基本块：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entry&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if.then&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if.else&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;。
每个基本块都将被转换为单独的DAG。&lt;/p&gt;
&lt;div class=&quot;language-llvm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dso_local&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;local_unnamed_addr&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;entry:&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%cmp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;icmp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;eq&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.else&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;if.then:&lt;/span&gt;                                          &lt;span class=&quot;c1&quot;&gt;; preds = %entry&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%call&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)*&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@hello100&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)*)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%return&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;if.else:&lt;/span&gt;                                          &lt;span class=&quot;c1&quot;&gt;; preds = %entry&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%call1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;bitcast&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(...)*&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;@helloOther&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)*)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;vg&quot;&gt;#2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%return&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;return:&lt;/span&gt;                                           &lt;span class=&quot;c1&quot;&gt;; preds = %if.else, %if.then&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;%retval.0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;phi&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%call1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%if.else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;%retval.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Selection DAG具有以下属性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个节点都是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDNode&lt;/code&gt;类的实例，代表一个操作，如加、减、乘等。
操作类型都定义在文件&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include/llvm/CodeGen/ISDOpcodes.h&lt;/code&gt;中。&lt;/li&gt;
  &lt;li&gt;每个节点都有0个或多个操作数，操作数由其他节点定义，用指向该节点的边表示，边是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDValue&lt;/code&gt;类的实例。&lt;/li&gt;
  &lt;li&gt;操作产生的值的类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTV&lt;/code&gt;（Machine Value Type），比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i8&lt;/code&gt;，它们分别表示1位和8位整数。&lt;/li&gt;
  &lt;li&gt;具有副作用的节点会强制对操作进行排序，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loads&lt;/code&gt;语句，它们具有类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVT::Other&lt;/code&gt;的特殊chain值，
既作为输入操作数又作为输出操作数。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ISD::EntryToken&lt;/code&gt;类型的叶节点是代码的入口。&lt;/li&gt;
  &lt;li&gt;DAG的根节点是带有链操作数的最终副作用节点。这是的代码块的最后一个操作，例如函数结尾处的返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;警告！&lt;/strong&gt;LLVM后端的类型系统非常有限。
当输入的LLVM IR被转换为DAG时，许多有用的类型信息被丢弃。
最值得注意的丢弃是指针类型，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVT&lt;/code&gt;类的类型列表完全没有包含指针类型。
因此，指针在DAG中使用整数类型表示，所以很难判断一个节点(如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;)的操作数是指针还是整数。&lt;/p&gt;

&lt;p&gt;这是我从MUL函数获得的初始Selection DAG。
&lt;img src=&quot;http://localhost:4000/assets/riscw/llvm-4-dag-before-combine1.png&quot; alt=&quot;Selection DAG&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 指令选择 我们先前简要介绍了LLVM后端的工作过程。 在这篇文章中，我们将更深入地了解这个过程的第一个阶段：指令选择。 我们的目的是在了解RISCW后端的具体实现之前，了解它的工作原理以及如何配置它。 注意：LLVM文档对指令选择的工作原理给出了简短而清晰的描述， 这篇文章通过示例来重新说明这一点。 注意：本文中显示的示例是使用我们的RISCW后端框架构建的。可以在这里找到它的来源。 指令选择过程将LLVM IR转化为指令序列，该指令序列使用了无穷数量的寄存器。 该过程分为以下几个阶段： 构建初始DAG 优化 类型合法化 优化 操作合法化 优化 目标指令选择 调度和形成 我觉得通过例子来了解发生的事情会比较容易，我们将考虑指令选择如何转换下面的C程序。 该代码包含一个MUL函数，该函数接受64位参数x和32位参数y。 参数相乘，并返回32位整数结果。 unsigned int MUL(unsigned long long int x, unsigned int y) { return x * y; } 构建DAG 这是指令选择的第一阶段。 它接受LLVM IR作为输入， 并产生Selection DAG(有向无环图)作为输出。 指令选择过程中的每个其他阶段都在DAG上执行，直到产生输出指令序列。 正如前面几篇文章所讨论的，LLVM IR是前端工具(如Clang)根据C代码生成，随后由LLVM优化器进行优化。 下面是C程序的LLVM IR: define dso_local i32 @MUL(i64 %x, i32 %y) local_unnamed_addr #0 { entry: %0 = trunc i64 %x to i32 %conv1 = mul i32 %0, %y ret i32 %conv1 } Selection DAG实际上是一种精巧的树型数据结构，它表示LLVM IR中的基本块。 基本块是不包含分支目的地（入口除外）和分支指令（出口除外）的指令序列。 示例MUL函数非常简单，它只有一个称为入口的基本块，其他函数通常具有多个基本块。 例如，下面的hello函数具有四个基本块：entry，if.then，if.else和return。 每个基本块都将被转换为单独的DAG。 define dso_local i32 @hello(i32 %x) local_unnamed_addr #0 { entry: %cmp = icmp eq i32 %x, 100 br i1 %cmp, label %if.then, label %if.else if.then: ; preds = %entry %call = tail call i32 bitcast (i32 (...)* @hello100 to i32 (i32)*)(i32 100) #2 br label %return if.else: ; preds = %entry %call1 = tail call i32 bitcast (i32 (...)* @helloOther to i32 (i32)*)(i32 %x) #2 br label %return return: ; preds = %if.else, %if.then %retval.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ] ret i32 %retval.0 } Selection DAG具有以下属性： 每个节点都是SDNode类的实例，代表一个操作，如加、减、乘等。 操作类型都定义在文件include/llvm/CodeGen/ISDOpcodes.h中。 每个节点都有0个或多个操作数，操作数由其他节点定义，用指向该节点的边表示，边是SDValue类的实例。 操作产生的值的类型为MTV（Machine Value Type），比如i1和i8，它们分别表示1位和8位整数。 具有副作用的节点会强制对操作进行排序，例如return和loads语句，它们具有类型为MVT::Other的特殊chain值， 既作为输入操作数又作为输出操作数。 ISD::EntryToken类型的叶节点是代码的入口。 DAG的根节点是带有链操作数的最终副作用节点。这是的代码块的最后一个操作，例如函数结尾处的返回。 警告！LLVM后端的类型系统非常有限。 当输入的LLVM IR被转换为DAG时，许多有用的类型信息被丢弃。 最值得注意的丢弃是指针类型，MVT类的类型列表完全没有包含指针类型。 因此，指针在DAG中使用整数类型表示，所以很难判断一个节点(如add)的操作数是指针还是整数。 这是我从MUL函数获得的初始Selection DAG。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(四)：配置构建系统</title><link href="http://localhost:4000/blog/RISCW-4.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(四)：配置构建系统" /><published>2020-12-08T12:30:38+08:00</published><updated>2020-12-08T12:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-4</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-4.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;配置构建系统&quot;&gt;配置构建系统&lt;/h2&gt;

&lt;p&gt;在前面，我们提到每个LLVM后端都有一个单独的目录&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM/lib/Target&lt;/code&gt;，后端的大部分代码都在其中。
此外，LLVM依赖CMake为实际的构建系统(如Make、Ninja等)生成构建文件。
在这篇文章中，我们将仔细研究其中的一些CMake配置文件。&lt;/p&gt;

&lt;p&gt;注意:RISCW后端代码可以在&lt;a href=&quot;https://github.com/andresag01/llvm-project/commit/274cfea0f9662f0ed49f6132b0424323d0b11750&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h3 id=&quot;cmake配置文件&quot;&gt;CMake配置文件&lt;/h3&gt;

&lt;p&gt;回想一下，RISCW后端存放在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;目录下。
该目录及其子目录都有两个构建文件(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;)，描述后端模块的结构，提供链接信息等。
RISCW后端目前非常简单，目录结构是这样的:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm/lib/Target/RISCW
|- CMakeLists.txt
|- LLVMBuild.txt
|- Other C++, TableGen, etc files
|- TargetInfo/
|  |- CMakeLists.txt
|  |- LLVMBuild.txt
|  |- Other C++, TableGen, etc files
|- MCTargetDesc/
   |- CMakeLists.txt
   |- LLVMBuild.txt
   |- Other C++, TableGen, etc files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;每个使用CMake的项目都会包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;文件&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，RISCW也不例外。
这些文件包含一系列CMake指令，这些指令用于驱动构建文件的生成。
在LLVM后端中，CMake会根据这些指令执行一些操作，例如指示要编译的C++源文件或生成TableGen指令。
LLVMBuild.txt文件对当前目录中包含的组件提供了描述。&lt;/p&gt;

&lt;h3 id=&quot;llvmbuildtxt文件&quot;&gt;LLVMBuild.txt文件&lt;/h3&gt;

&lt;p&gt;让我们看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/LLVMBuild.txt&lt;/code&gt;的内容。&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;subdirectories&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;MCTargetDesc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TargetInfo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;component_&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;TargetGroup&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;has_asmprinter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;component_&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Library&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWCodeGen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;required_libraries&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;AsmPrinter&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;CodeGen&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;MC&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWDesc&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCWInfo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;SelectionDAG&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Support&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Target&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;add_to_library_groups&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RISCW&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该文件告诉构建系统RISCW后端具有两个组件。
其中一个是顶级组件RISCW，其类型为TargetGroup，该类型表明RISCW是一个后端，构建系统对该类型有一些特殊处理。 
Target是RISCW的父组件。 
请注意，此命名与LLVM后端的目录结构匹配，即&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;。
RISCW的名称也不是任意的，它必须与后端的TableGen文件中的定义匹配。&lt;/p&gt;

&lt;p&gt;LLVM后端提供了一系列可选功能，
例如assembly printing，assembly parsing等，
LLVMBuild.txt文件表明了后端支持哪些可选功能。
比如，最后一行告诉构建系统RISCW后端实现了assembly printing功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;查看现有后端（如ARM或RISCV）中的代码，以了解它们除了has_asmprinter之外还启用了哪些功能。&lt;/p&gt;

&lt;p&gt;LLVMBuild.txt文件还定义了第二个名为RISCWCodeGen的组件，其类型为Library，其父级为RISCW。
另外，文件还指明了RISCWCodeGen需要的依赖库，例如AsmPrinter，CodeGen等，构建LLVM时，缺少库会导致链接错误。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;的每个子目录也会包含一个LLVMBuild.txt文件，该文件使用RISCW作为父级来定义自己的组件。&lt;/p&gt;

&lt;h3 id=&quot;cmakeliststxt文件&quot;&gt;CMakeLists.txt文件&lt;/h3&gt;

&lt;p&gt;让我们看一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW/CMakeLists.txt&lt;/code&gt;文件的内容。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM_TARGET_DEFINITIONS RISCW.td&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

tablegen&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM RISCWGenRegisterInfo.inc &lt;span class=&quot;nt&quot;&gt;-gen-register-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
tablegen&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;LLVM RISCWGenInstrInfo.inc &lt;span class=&quot;nt&quot;&gt;-gen-instr-info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Other TableGen commands&lt;/span&gt;

add_public_tablegen_target&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;RISCWCommonTableGen&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# RISCWCodeGen should match with LLVMBuild.txt RISCWCodeGen&lt;/span&gt;
add_llvm_target&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;RISCWCodeGen
  RISCWAsmPrinter.cpp
  &lt;span class=&quot;c&quot;&gt;# Other files&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Should match with &quot;subdirectories =  MCTargetDesc TargetInfo&quot; in LLVMBuild.txt&lt;/span&gt;
add_subdirectory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TargetInfo&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
add_subdirectory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;MCTargetDesc&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;文件顶部的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set&lt;/code&gt;命令将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVM_TARGET_DEFINITION&lt;/code&gt;定义为`RISCW.td**。
这个文件通常包含一些顶级定义，
并通过包含其他文件的方式来引入其他TableGen定义——我们将在后面的文章中更仔细地研究TableGen，
但是请随时查看代码库中的RISCW.td。&lt;/p&gt;

&lt;p&gt;然后我们在CMake文件中看到一些TableGen命令。
它们命令构建系统使TableGen工具根据&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.td&lt;/code&gt;文件生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWGen*.inc&lt;/code&gt;。
这些&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.inc&lt;/code&gt;文件实际上就是传统的C++代码，在编译完LLVM之后，你可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build/lib/Target/RISCW&lt;/code&gt;的构建目录中找到它们；它们可以用于调试，但是不容易阅读。&lt;/p&gt;

&lt;p&gt;接下来的命令，也就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_target&lt;/code&gt;，
指定了当前目录中要构建的C++文件，被指定的文件不能位于子目录中。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add_llvm_target&lt;/code&gt;命令的第一个参数是目标的名称，并且应该与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;中定义名称匹配。&lt;/p&gt;

&lt;p&gt;最后，CMakeLists.txt指定了CMake应该查看的子目录，在后端RISCW中，只有两个:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TargetInfo&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MCTargetDesc&lt;/code&gt;。
子目录中的CMakeLists.txt与此类似，但要简单得多!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;后端文件的命名约定通常很重要，显然应该与构建文件的内容相匹配。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set(LLVM_TARGET_DEFINITIONS RISCW.td)&lt;/code&gt;命令要求&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCW.td&lt;/code&gt;存在!
一定要仔细检查这些错误，因为构建错误可能有点含糊不清。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;您可以在&lt;a href=&quot;https://cmake.org/overview/&quot;&gt;此处&lt;/a&gt;找到有关CMake的更多信息。 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 配置构建系统 在前面，我们提到每个LLVM后端都有一个单独的目录LLVM/lib/Target，后端的大部分代码都在其中。 此外，LLVM依赖CMake为实际的构建系统(如Make、Ninja等)生成构建文件。 在这篇文章中，我们将仔细研究其中的一些CMake配置文件。 注意:RISCW后端代码可以在这里找到。 CMake配置文件 回想一下，RISCW后端存放在llvm/lib/Target/RISCW目录下。 该目录及其子目录都有两个构建文件(CMakeLists.txt和LLVMBuild.txt)，描述后端模块的结构，提供链接信息等。 RISCW后端目前非常简单，目录结构是这样的: llvm/lib/Target/RISCW |- CMakeLists.txt |- LLVMBuild.txt |- Other C++, TableGen, etc files |- TargetInfo/ | |- CMakeLists.txt | |- LLVMBuild.txt | |- Other C++, TableGen, etc files |- MCTargetDesc/ |- CMakeLists.txt |- LLVMBuild.txt |- Other C++, TableGen, etc files 每个使用CMake的项目都会包含CMakeLists.txt文件3，RISCW也不例外。 这些文件包含一系列CMake指令，这些指令用于驱动构建文件的生成。 在LLVM后端中，CMake会根据这些指令执行一些操作，例如指示要编译的C++源文件或生成TableGen指令。 LLVMBuild.txt文件对当前目录中包含的组件提供了描述。 LLVMBuild.txt文件 让我们看一下llvm/lib/Target/RISCW/LLVMBuild.txt的内容。 [common] subdirectories = MCTargetDesc TargetInfo [component_0] type = TargetGroup name = RISCW parent = Target has_asmprinter = 1 [component_1] type = Library name = RISCWCodeGen parent = RISCW required_libraries = AsmPrinter CodeGen Core MC RISCWDesc RISCWInfo SelectionDAG Support Target add_to_library_groups = RISCW 该文件告诉构建系统RISCW后端具有两个组件。 其中一个是顶级组件RISCW，其类型为TargetGroup，该类型表明RISCW是一个后端，构建系统对该类型有一些特殊处理。 Target是RISCW的父组件。 请注意，此命名与LLVM后端的目录结构匹配，即llvm/lib/Target/RISCW。 RISCW的名称也不是任意的，它必须与后端的TableGen文件中的定义匹配。 LLVM后端提供了一系列可选功能， 例如assembly printing，assembly parsing等， LLVMBuild.txt文件表明了后端支持哪些可选功能。 比如，最后一行告诉构建系统RISCW后端实现了assembly printing功能。 注意：查看现有后端（如ARM或RISCV）中的代码，以了解它们除了has_asmprinter之外还启用了哪些功能。 LLVMBuild.txt文件还定义了第二个名为RISCWCodeGen的组件，其类型为Library，其父级为RISCW。 另外，文件还指明了RISCWCodeGen需要的依赖库，例如AsmPrinter，CodeGen等，构建LLVM时，缺少库会导致链接错误。 llvm/lib/Target/RISCW的每个子目录也会包含一个LLVMBuild.txt文件，该文件使用RISCW作为父级来定义自己的组件。 CMakeLists.txt文件 让我们看一下llvm/lib/Target/RISCW/CMakeLists.txt文件的内容。 set(LLVM_TARGET_DEFINITIONS RISCW.td) tablegen(LLVM RISCWGenRegisterInfo.inc -gen-register-info) tablegen(LLVM RISCWGenInstrInfo.inc -gen-instr-info) # Other TableGen commands add_public_tablegen_target(RISCWCommonTableGen) # RISCWCodeGen should match with LLVMBuild.txt RISCWCodeGen add_llvm_target(RISCWCodeGen RISCWAsmPrinter.cpp # Other files ) # Should match with &quot;subdirectories = MCTargetDesc TargetInfo&quot; in LLVMBuild.txt add_subdirectory(TargetInfo) add_subdirectory(MCTargetDesc) 文件顶部的set命令将LLVM_TARGET_DEFINITION定义为`RISCW.td**。 这个文件通常包含一些顶级定义， 并通过包含其他文件的方式来引入其他TableGen定义——我们将在后面的文章中更仔细地研究TableGen， 但是请随时查看代码库中的RISCW.td。 然后我们在CMake文件中看到一些TableGen命令。 它们命令构建系统使TableGen工具根据*.td文件生成RISCWGen*.inc。 这些*.inc文件实际上就是传统的C++代码，在编译完LLVM之后，你可以在build/lib/Target/RISCW的构建目录中找到它们；它们可以用于调试，但是不容易阅读。 接下来的命令，也就是add_llvm_target， 指定了当前目录中要构建的C++文件，被指定的文件不能位于子目录中。 add_llvm_target命令的第一个参数是目标的名称，并且应该与LLVMBuild.txt中定义名称匹配。 最后，CMakeLists.txt指定了CMake应该查看的子目录，在后端RISCW中，只有两个:TargetInfo和MCTargetDesc。 子目录中的CMakeLists.txt与此类似，但要简单得多! 注意:后端文件的命名约定通常很重要，显然应该与构建文件的内容相匹配。 例如，set(LLVM_TARGET_DEFINITIONS RISCW.td)命令要求RISCW.td存在! 一定要仔细检查这些错误，因为构建错误可能有点含糊不清。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617; 您可以在此处找到有关CMake的更多信息。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(三)：创建后端</title><link href="http://localhost:4000/blog/RISCW-3.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(三)：创建后端" /><published>2020-12-06T13:30:38+08:00</published><updated>2020-12-06T13:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-3</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-3.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;创建后端&quot;&gt;创建后端&lt;/h2&gt;

&lt;p&gt;开发LLVM后端并不是一件特别吸引人的事情。
您很快就会意识到，这项工作在很大程度上就是从其他现有后端复制代码。
在线论坛上，LLVM开发者建议从“复制一个现有的后端，重命名并修改它以适应您的需要”开。
但是即使是相对较小的后端，比如Lanai或XCore，也相当复杂，而且代码也不容易理解！&lt;/p&gt;

&lt;p&gt;在本系列文章中，将采取略有不同的方法。
我们将使用现有的LLVM后端作为起点，但我已经删除了大部分代码，并将其减少到编译一个(很小的)程序所需的最低限度。
精简的后端，称为RISCW，非常简单，可以帮助理解LLVM目标独立代码生成器，而不必纠缠于细节。
在这篇文章的其余部分，我将使用RISCW后端来展示如何创建一个新的LLVM后端。
我们还将看到如何用一个实验性的后端构建LLVM，甚至编译一个(非常简单的) C程序到汇编。&lt;/p&gt;

&lt;h3 id=&quot;triple和elf配置&quot;&gt;Triple和ELF配置&lt;/h3&gt;

&lt;p&gt;我们首先为后端配置一个新的目标描述Triple。
由于历史原因，Triple编码了目标平台的重要信息（如体系结构、供应商和操作系统）。
以下是配置一个新的Triple的步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在llvm/include/llvm/ADT/Triple.h用Triple声明一个新的体系结构 (见这里)。&lt;/li&gt;
  &lt;li&gt;提供字符串和Triple之间的类型转换(参见这里,这里及这里)。&lt;/li&gt;
  &lt;li&gt;指出后端支持的目标文件类型，例如ELF、COFF等，ricw只支持ELF(参见这里)。&lt;/li&gt;
  &lt;li&gt;指出目标平台的字平台，例如32位或64位，以及指针的大小(请参阅这里,这里及这里)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;你可以在这里和这里找到更多关于Triple的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;指令集并不一定意味着指针的大小。
例如，在为RV64编译时，指针并不总是64位的。
指针大小通常由ABI给出，在64位机器中，它可以是ilp32(即int、long和指针为32位)。&lt;/p&gt;

&lt;p&gt;下面的参数用于配置ELF:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个枚举值作为RISCW的体系结构的标识(见此处)。
这个值被编码在ELF文件头的e_machine字段中。
这个值不是随意设置的; 它必须取得授权，例如:0xF3 for RISCV。
但是我们现在将它设置为一个未使用的值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;声明ELF重定位类型(见这里和这里)。
同样，这些是依赖于架构的，这里列出了用于RISCV的类型。
在这个阶段，我们将简单地为RISCW放置了占位符。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件格式名称(见此处)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指示给定类的目标描述Triple(见此处)。目前，ELF头中的类是一个字节，用于对格式是32位还是64位进行编码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;查看wikipedia获取更多关于ELF文件的信息。&lt;/p&gt;

&lt;h3 id=&quot;配置驱动器&quot;&gt;配置驱动器&lt;/h3&gt;

&lt;p&gt;回想一下，我们使用clang将输入的C代码编译成LLVM IR。
但是clang不仅仅是我们的编译器前端，它也是一个驱动器，类似GCC，驱动编译流水线将输入的C程序转换为另一个表示，比如把C转换为汇编或目标代码。
因此，我们需要告诉clang&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新后端的支持特性。例如，clang需要知道RISCW是32位还是64位。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新后端的编译流程。例如，它应该使用什么汇编程序? 什么连接器? 有哪些包括路径等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们可以通过添加一个新的target类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;来告诉clang有关RISCW的信息，该类与LLVM已有的target类一起被实例化，如这里所示。
该类在这里和这里分别被声明和定义。
在这段代码中有一些重要的事情需要强调:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;通过字符串描述数据布局。这个字符串编码许多重要信息，比如指针中每一位、堆栈对齐要求等。&lt;/li&gt;
  &lt;li&gt;基本C数据类型的大小。&lt;/li&gt;
  &lt;li&gt;函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo::getTargetDefines(**&lt;/code&gt;指示编译时定义的C预处理器宏，例如，这些宏是在使用RISCV后端编译代码时定义的。
宏通常描述后端支持的体系结构、ABI、启用/禁用任何特性等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;一个后端可能支持多个指令集和ABI，因此驱动器的配置必须根据选定的目标Triple进行更改。
例如，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISCWTargetInfo&lt;/code&gt;根据Triple包含riscv32还是riscv64来更改数据布局字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;这里可以查看RISCWTargetInfo的父类TargetInfo的声明。
它包含了更多的可以配置的选项。&lt;/p&gt;

&lt;p&gt;配置工具链相对简单。
我们只需要实现一个从Toolchain继承的RISCWToolChain类，如下所示。
代码基本上是不言自明的，通过覆盖ToolChain类的成员，您可以修改更多的选项(见此处)。&lt;/p&gt;

&lt;h3 id=&quot;创建新target&quot;&gt;创建新Target&lt;/h3&gt;

&lt;p&gt;每个后端在llvm/lib/Target下都有一个单独的目录，其中包含后端的大部分代码。
我们不会在这篇文章中深入讨论代码的细节(稍后我们会这样做) ，因为即使是一个很小的后端，比如RISCW，也有很多文件。
目前，我们可以将这些文件大致分为三类:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TableGen文件&lt;/strong&gt;LLVM目标无关代码生成框架实现了一个精心设计的模式匹配算法，用于为输入的程序选择指令。
待匹配的模式使用TableGen语法描述。
此外，TableGen文件还描述了target在体系结构方面的重要特性，如寄存器的数量和调用约定等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Build文件&lt;/strong&gt;后端的每个目录都必须被声明，否则它将不会被构建。
此外，我们的后端的顶部目录(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llvm/lib/Target/RISCW&lt;/code&gt;) ，以及每个子目录必须包含两个构建文件:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LLVMBuild.txt&lt;/code&gt;，
前者将源文件和任何子目录添加为生成目标，而后者为生成目标设置简单的生成参数，参数包括生成目标的名称、链接所需的库等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;C++文件&lt;/strong&gt;包含了大量的后端代码，实现了从简单的配置选项到更复杂的指令选择功能(TableGen没有实现或不能实现)的所有功能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;建立实验性后端&quot;&gt;建立实验性后端&lt;/h3&gt;

&lt;p&gt;现在，一切都已经建立，我们可以构建带有RISCW后端的LLVM。
但是我们不能简单地根据上一章的内容修改CMake的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/code&gt;选项，以包含RISCW，因为后端仍处于试验阶段。
相反，我们使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&lt;/code&gt;选项，如下:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ninja&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clang&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM;Lanai;RISCV&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;RISCW&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Debug&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_ASSERTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;On ../llvm
ninja
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;当构建完成后，你可以检查RISCW现在是否是一个可用的后端，如下所示:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./build/bin/llc &lt;span class=&quot;nt&quot;&gt;--version&lt;/span&gt;
LLVM &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;http://llvm.org/&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
  LLVM version 10.0.1
  DEBUG build with assertions.
  Default target: x86_64-unknown-linux-gnu
  Host CPU: znver2

  Registered Targets:
    arm     - ARM
    armeb   - ARM &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;big endian&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    lanai   - Lanai
    riscv32 - 32-bit RISC-V
    riscv64 - 64-bit RISC-V
    riscw   - 32-bit RISC-V         &amp;lt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; YAY!!
    thumb   - Thumb
    thumbeb - Thumb &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;big endian&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;编译c程序&quot;&gt;编译C程序&lt;/h3&gt;
&lt;p&gt;我们的RISCW后端只能发出两条add和ret指令，而且它不能正确处理函数调用、堆栈和几乎所有其他的东西！
因此，我们将约束自己，只编译这个小函数:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int a, int b&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;a + b&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就这样，我们得到了这样一个代码:&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	.text
	.file	&lt;span class=&quot;s2&quot;&gt;&quot;test.c&quot;&lt;/span&gt;
	.globl	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;                    &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Begin &lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
	.type	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;,@function
&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;:                                   &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; @test
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; %bb.0:                                &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; %entry
	add	x0, x1, x0
	ret
.Lfunc_end0:
	.size	&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;, .Lfunc_end0-test
                                        &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; End &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;
	.ident	&lt;span class=&quot;s2&quot;&gt;&quot;clang version 10.0.1 (https://github.com/llvm/llvm-project 89f2d2cc3bba7cb12cee346b3205cb0335e758cd)&quot;&lt;/span&gt;
	.section	&lt;span class=&quot;s2&quot;&gt;&quot;.note.GNU-stack&quot;&lt;/span&gt;,&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;,@progbits
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;有很多东西缺失了，代码实际上是不正确的，在RISCV中的x0是一个硬编码为0的只读寄存器。
但是我认为我们已经达到了目标: 建立了一个最小的LLVM后端，可以很容易地用更多的特性进行扩展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;如果您使用上一篇文章中的命令来编译上面的测试函数，请确保为clang设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-target riscw&lt;/code&gt;和为llc设置了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-march=riscw&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;试图编译更复杂的程序将导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cannot select...&lt;/code&gt;错误。如果你感兴趣，就试一试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;您可以通过将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-debug&lt;/code&gt;选项传递给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;llc&lt;/code&gt;来指示编译器打印调试信息。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 创建后端 开发LLVM后端并不是一件特别吸引人的事情。 您很快就会意识到，这项工作在很大程度上就是从其他现有后端复制代码。 在线论坛上，LLVM开发者建议从“复制一个现有的后端，重命名并修改它以适应您的需要”开。 但是即使是相对较小的后端，比如Lanai或XCore，也相当复杂，而且代码也不容易理解！ 在本系列文章中，将采取略有不同的方法。 我们将使用现有的LLVM后端作为起点，但我已经删除了大部分代码，并将其减少到编译一个(很小的)程序所需的最低限度。 精简的后端，称为RISCW，非常简单，可以帮助理解LLVM目标独立代码生成器，而不必纠缠于细节。 在这篇文章的其余部分，我将使用RISCW后端来展示如何创建一个新的LLVM后端。 我们还将看到如何用一个实验性的后端构建LLVM，甚至编译一个(非常简单的) C程序到汇编。 Triple和ELF配置 我们首先为后端配置一个新的目标描述Triple。 由于历史原因，Triple编码了目标平台的重要信息（如体系结构、供应商和操作系统）。 以下是配置一个新的Triple的步骤: 在llvm/include/llvm/ADT/Triple.h用Triple声明一个新的体系结构 (见这里)。 提供字符串和Triple之间的类型转换(参见这里,这里及这里)。 指出后端支持的目标文件类型，例如ELF、COFF等，ricw只支持ELF(参见这里)。 指出目标平台的字平台，例如32位或64位，以及指针的大小(请参阅这里,这里及这里)。 注意:你可以在这里和这里找到更多关于Triple的信息。 注意:指令集并不一定意味着指针的大小。 例如，在为RV64编译时，指针并不总是64位的。 指针大小通常由ABI给出，在64位机器中，它可以是ilp32(即int、long和指针为32位)。 下面的参数用于配置ELF: 创建一个枚举值作为RISCW的体系结构的标识(见此处)。 这个值被编码在ELF文件头的e_machine字段中。 这个值不是随意设置的; 它必须取得授权，例如:0xF3 for RISCV。 但是我们现在将它设置为一个未使用的值。 声明ELF重定位类型(见这里和这里)。 同样，这些是依赖于架构的，这里列出了用于RISCV的类型。 在这个阶段，我们将简单地为RISCW放置了占位符。 文件格式名称(见此处)。 指示给定类的目标描述Triple(见此处)。目前，ELF头中的类是一个字节，用于对格式是32位还是64位进行编码。 注意:查看wikipedia获取更多关于ELF文件的信息。 配置驱动器 回想一下，我们使用clang将输入的C代码编译成LLVM IR。 但是clang不仅仅是我们的编译器前端，它也是一个驱动器，类似GCC，驱动编译流水线将输入的C程序转换为另一个表示，比如把C转换为汇编或目标代码。 因此，我们需要告诉clang 新后端的支持特性。例如，clang需要知道RISCW是32位还是64位。 新后端的编译流程。例如，它应该使用什么汇编程序? 什么连接器? 有哪些包括路径等等。 我们可以通过添加一个新的target类RISCWTargetInfo来告诉clang有关RISCW的信息，该类与LLVM已有的target类一起被实例化，如这里所示。 该类在这里和这里分别被声明和定义。 在这段代码中有一些重要的事情需要强调: RISCWTargetInfo通过字符串描述数据布局。这个字符串编码许多重要信息，比如指针中每一位、堆栈对齐要求等。 基本C数据类型的大小。 函数RISCWTargetInfo::getTargetDefines(**指示编译时定义的C预处理器宏，例如，这些宏是在使用RISCV后端编译代码时定义的。 宏通常描述后端支持的体系结构、ABI、启用/禁用任何特性等 注意:一个后端可能支持多个指令集和ABI，因此驱动器的配置必须根据选定的目标Triple进行更改。 例如，RISCWTargetInfo根据Triple包含riscv32还是riscv64来更改数据布局字符串。 注意:这里可以查看RISCWTargetInfo的父类TargetInfo的声明。 它包含了更多的可以配置的选项。 配置工具链相对简单。 我们只需要实现一个从Toolchain继承的RISCWToolChain类，如下所示。 代码基本上是不言自明的，通过覆盖ToolChain类的成员，您可以修改更多的选项(见此处)。 创建新Target 每个后端在llvm/lib/Target下都有一个单独的目录，其中包含后端的大部分代码。 我们不会在这篇文章中深入讨论代码的细节(稍后我们会这样做) ，因为即使是一个很小的后端，比如RISCW，也有很多文件。 目前，我们可以将这些文件大致分为三类: TableGen文件LLVM目标无关代码生成框架实现了一个精心设计的模式匹配算法，用于为输入的程序选择指令。 待匹配的模式使用TableGen语法描述。 此外，TableGen文件还描述了target在体系结构方面的重要特性，如寄存器的数量和调用约定等。 Build文件后端的每个目录都必须被声明，否则它将不会被构建。 此外，我们的后端的顶部目录(llvm/lib/Target/RISCW) ，以及每个子目录必须包含两个构建文件:CMakeLists.txt和LLVMBuild.txt， 前者将源文件和任何子目录添加为生成目标，而后者为生成目标设置简单的生成参数，参数包括生成目标的名称、链接所需的库等。 C++文件包含了大量的后端代码，实现了从简单的配置选项到更复杂的指令选择功能(TableGen没有实现或不能实现)的所有功能。 建立实验性后端 现在，一切都已经建立，我们可以构建带有RISCW后端的LLVM。 但是我们不能简单地根据上一章的内容修改CMake的-DLLVM_TARGETS_TO_BUILD选项，以包含RISCW，因为后端仍处于试验阶段。 相反，我们使用-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD选项，如下: cmake -G &quot;Ninja&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_TARGETS_TO_BUILD=&quot;ARM;Lanai;RISCV&quot; -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=&quot;RISCW&quot; -DCMAKE_BUILD_TYPE=&quot;Debug&quot; -DLLVM_ENABLE_ASSERTIONS=On ../llvm ninja 当构建完成后，你可以检查RISCW现在是否是一个可用的后端，如下所示: $ ./build/bin/llc --version LLVM (http://llvm.org/): LLVM version 10.0.1 DEBUG build with assertions. Default target: x86_64-unknown-linux-gnu Host CPU: znver2 Registered Targets: arm - ARM armeb - ARM (big endian) lanai - Lanai riscv32 - 32-bit RISC-V riscv64 - 64-bit RISC-V riscw - 32-bit RISC-V &amp;lt;== YAY!! thumb - Thumb thumbeb - Thumb (big endian) 编译C程序 我们的RISCW后端只能发出两条add和ret指令，而且它不能正确处理函数调用、堆栈和几乎所有其他的东西！ 因此，我们将约束自己，只编译这个小函数: int test(int a, int b) { return a + b; } 就这样，我们得到了这样一个代码: .text .file &quot;test.c&quot; .globl test ; -- Begin function test .type test,@function test: ; @test ; %bb.0: ; %entry add x0, x1, x0 ret .Lfunc_end0: .size test, .Lfunc_end0-test ; -- End function .ident &quot;clang version 10.0.1 (https://github.com/llvm/llvm-project 89f2d2cc3bba7cb12cee346b3205cb0335e758cd)&quot; .section &quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits 有很多东西缺失了，代码实际上是不正确的，在RISCV中的x0是一个硬编码为0的只读寄存器。 但是我认为我们已经达到了目标: 建立了一个最小的LLVM后端，可以很容易地用更多的特性进行扩展。 注意:如果您使用上一篇文章中的命令来编译上面的测试函数，请确保为clang设置了-target riscw和为llc设置了-march=riscw。 注意:试图编译更复杂的程序将导致cannot select...错误。如果你感兴趣，就试一试。 注意:您可以通过将-debug选项传递给llc来指示编译器打印调试信息。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(二)：入门</title><link href="http://localhost:4000/blog/RISCW-2.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(二)：入门" /><published>2020-12-04T19:30:38+08:00</published><updated>2020-12-04T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-2</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-2.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;

&lt;p&gt;在为新项目编写代码之前，我通常会配置环境，并对查看经存在的代码，这就是这一节要做的。在这一节中，我将展示如何下载编译LLVM和其他对调试有用的工具。我们还将了解如何使用现有的LLVM后端和GNU工具链来编译、汇编、链接和运行程序。&lt;/p&gt;

&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;

&lt;p&gt;我正在使用Ubuntu，但是你应该能够在其他系统中重复这些步骤，而且(相对来说)几乎没有什么不同。您将需要以下工具来构建软件。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Makefile&lt;/li&gt;
  &lt;li&gt;C/C++ Compiler – 我用 GCC 9.2.1&lt;/li&gt;
  &lt;li&gt;autotools&lt;/li&gt;
  &lt;li&gt;CMake&lt;/li&gt;
  &lt;li&gt;Ninja&lt;/li&gt;
  &lt;li&gt;Git&lt;/li&gt;
  &lt;li&gt;大量耐心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;我可能忘记了一些东西，但是构建系统会通过一个错误告诉您；&lt;/p&gt;

&lt;h3 id=&quot;编译llvm&quot;&gt;编译LLVM&lt;/h3&gt;

&lt;p&gt;LLVM维护者已经建立了这个方便的repo，它包含LLVM和工具链的其他部分，比如Clang。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/llvm/llvm-project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在本系列文章中，我们将使用llvm 10.0.1，我建议您也使用该版本的LLVM。
因为LLVM的变化非常快，这里显示的一些代码在旧/新版本中可能无法工作。
不过，原理应该大致相同。&lt;/p&gt;

&lt;p&gt;LLVM使用CMake为构建系统生成构建文件，LLVM支持的构建系有：Ninja，Makefiles，Visual Studio和XCode。
我通常使用Ninja，因为我认为它在我的系统中速度最快（我没有证据支持该判断！）。
您可以通过cmake命令的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-G&lt;/code&gt;参数来更改构建系统。&lt;/p&gt;

&lt;p&gt;CMake有很多选项，我鼓励您对其进行研究，因为有些选项对调试非常有帮助。
您可以在&lt;a href=&quot;https://llvm.org/docs/CMake.html&quot;&gt;这里&lt;/a&gt;阅读所有构建选项。
在本教程中，我将使用以下选项:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/code&gt; 构建编译器的其余部分，比如Clang。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/code&gt; 指定要构建的后端。查看其他后端的输出对调试很有帮助，但是如果添加太多，构建会花费很长时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/code&gt; 构建Debug版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-DLLVM_ENABLE_ASSERTIONS=On&lt;/code&gt; 启用断言，对调试很有帮助。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是在克隆repo之后构建LLVM的方法。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;llvm-project
git checkout llvmorg-10.0.1
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
cmake &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Ninja&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_PROJECTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clang&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_TARGETS_TO_BUILD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM;Lanai;RISCV&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Debug&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DLLVM_ENABLE_ASSERTIONS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;On ../llvm
ninja
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以在&lt;a href=&quot;https://llvm.org/docs/GettingStarted.html&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://llvm.org/docs/CMake.html&quot;&gt;这里&lt;/a&gt;找到更多有关构建LLVM的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以为Ninja传递&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-j &amp;lt;NUM_JOBS&amp;gt;&lt;/code&gt;选项，以指示要并行的作业数。 
过高的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;NUM_JOBS&amp;gt;&lt;/code&gt;会导致构建崩溃，并产生&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collect2：ld ...&lt;/code&gt;错误消息。&lt;/p&gt;

&lt;h3 id=&quot;编译risc-v的gnu工具链&quot;&gt;编译RISC V的GNU工具链&lt;/h3&gt;

&lt;p&gt;你可能有点困惑，为什么我建议构建GCC的RISC V后端？
难道我们不是要自己编写编译器后端吗？&lt;/p&gt;

&lt;p&gt;我们构建GCC的RISC V后端，是因为我们希望在初始阶段使用GCC的汇编器和链接器来测试LLVM后端生成的代码。
编译过程分为很多阶段，在初始阶段，我们已经有以下结构:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Clang 编译C代码到LLVM IR&lt;/li&gt;
  &lt;li&gt;LLVM 优化IR&lt;/li&gt;
  &lt;li&gt;LLVM后端 编译IR到汇编&lt;/li&gt;
  &lt;li&gt;GCC 汇编和链接可执行文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用以下命令下载，构建和安装GCC for RISCV。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/riscv/riscv-gnu-toolchain
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;riscv-gnu-toolchain
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;build
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;build
../configure &lt;span class=&quot;nt&quot;&gt;--with-arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;rv32gc &lt;span class=&quot;nt&quot;&gt;--with-abi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ilp32
make
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;请确保为指令集的正确变体（即RV32）构建GCC工具链，因为构建系统的默认值为RV64！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;GNU工具链支持RISC V的多个ABI，例如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32d&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ilp32f&lt;/code&gt;，这取决于您是否需要软浮点，硬浮点。&lt;/p&gt;

&lt;h3 id=&quot;编译c程序&quot;&gt;编译C程序&lt;/h3&gt;

&lt;p&gt;现在，构建和运行C代码的环境已经配置好了，尽管我们还没自己的后端（还！）。让我们从一个简单的C程序开始：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(void)
{
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，使用Clang将C代码编译为LLVM IR。
我们的计划是使用标准库中来自头文件stdio.h的函数printf，如果不能找到头文件，编译器会提示出错。
为了使用GCC自带的RISC V标准C库，我们使用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-isystem&lt;/code&gt;参数。
这会将包含所需头文件的目录添加到Clang预处理器的搜索目录列表中。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang &lt;span class=&quot;nt&quot;&gt;-O2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-emit-llvm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-target&lt;/span&gt; riscv64 &lt;span class=&quot;nt&quot;&gt;-isystem&lt;/span&gt; &amp;lt;PATH_TO_GCC&amp;gt;/riscv64-unknown-elf/include &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test.c &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.bc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的命令把C语言文件test.c编译到LLVM IR文件test.bc，这是专门为机器设计的语言人类很难直接阅读。
我们可以使用以下命令反汇编该文件：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llvm-dis test.bc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在，使用包含以下内容的后端将IR编译为程序集，而无需使用以下命令下载LLVM：
现在，使用LLVM自带的后端将IR编译为程汇编：&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llc &lt;span class=&quot;nt&quot;&gt;-march&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;riscv64 &lt;span class=&quot;nt&quot;&gt;-O2&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-filetype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;asm test.bc &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.S
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;GCC可以直接生成程序的二进制文件。
我将其分为两个步骤，但是您可以根据需要使用单个命令。&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;riscv64-unknown-elf-gcc &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; test.S &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; test.o
riscv64-unknown-elf-gcc test.o &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后，我们可以使用模拟器或真实硬件运行程序。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 入门 在为新项目编写代码之前，我通常会配置环境，并对查看经存在的代码，这就是这一节要做的。在这一节中，我将展示如何下载编译LLVM和其他对调试有用的工具。我们还将了解如何使用现有的LLVM后端和GNU工具链来编译、汇编、链接和运行程序。 环境 我正在使用Ubuntu，但是你应该能够在其他系统中重复这些步骤，而且(相对来说)几乎没有什么不同。您将需要以下工具来构建软件。 Makefile C/C++ Compiler – 我用 GCC 9.2.1 autotools CMake Ninja Git 大量耐心 注意：我可能忘记了一些东西，但是构建系统会通过一个错误告诉您； 编译LLVM LLVM维护者已经建立了这个方便的repo，它包含LLVM和工具链的其他部分，比如Clang。 git clone https://github.com/llvm/llvm-project 在本系列文章中，我们将使用llvm 10.0.1，我建议您也使用该版本的LLVM。 因为LLVM的变化非常快，这里显示的一些代码在旧/新版本中可能无法工作。 不过，原理应该大致相同。 LLVM使用CMake为构建系统生成构建文件，LLVM支持的构建系有：Ninja，Makefiles，Visual Studio和XCode。 我通常使用Ninja，因为我认为它在我的系统中速度最快（我没有证据支持该判断！）。 您可以通过cmake命令的-G参数来更改构建系统。 CMake有很多选项，我鼓励您对其进行研究，因为有些选项对调试非常有帮助。 您可以在这里阅读所有构建选项。 在本教程中，我将使用以下选项: -DLLVM_ENABLE_PROJECTS 构建编译器的其余部分，比如Clang。 -DLLVM_TARGETS_TO_BUILD 指定要构建的后端。查看其他后端的输出对调试很有帮助，但是如果添加太多，构建会花费很长时间。 -DCMAKE_BUILD_TYPE 构建Debug版本。 -DLLVM_ENABLE_ASSERTIONS=On 启用断言，对调试很有帮助。 以下是在克隆repo之后构建LLVM的方法。 cd llvm-project git checkout llvmorg-10.0.1 mkdir build cd build cmake -G &quot;Ninja&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_TARGETS_TO_BUILD=&quot;ARM;Lanai;RISCV&quot; -DCMAKE_BUILD_TYPE=&quot;Debug&quot; -DLLVM_ENABLE_ASSERTIONS=On ../llvm ninja 注意：您可以在这里和这里找到更多有关构建LLVM的信息。 注意：您可以为Ninja传递-j &amp;lt;NUM_JOBS&amp;gt;选项，以指示要并行的作业数。 过高的&amp;lt;NUM_JOBS&amp;gt;会导致构建崩溃，并产生collect2：ld ...错误消息。 编译RISC V的GNU工具链 你可能有点困惑，为什么我建议构建GCC的RISC V后端？ 难道我们不是要自己编写编译器后端吗？ 我们构建GCC的RISC V后端，是因为我们希望在初始阶段使用GCC的汇编器和链接器来测试LLVM后端生成的代码。 编译过程分为很多阶段，在初始阶段，我们已经有以下结构: Clang 编译C代码到LLVM IR LLVM 优化IR LLVM后端 编译IR到汇编 GCC 汇编和链接可执行文件 使用以下命令下载，构建和安装GCC for RISCV。 git clone https://github.com/riscv/riscv-gnu-toolchain cd riscv-gnu-toolchain mkdir build cd build ../configure --with-arch=rv32gc --with-abi=ilp32 make make install 注意：请确保为指令集的正确变体（即RV32）构建GCC工具链，因为构建系统的默认值为RV64！ 注意：GNU工具链支持RISC V的多个ABI，例如ilp32，ilp32d和ilp32f，这取决于您是否需要软浮点，硬浮点。 编译C程序 现在，构建和运行C代码的环境已经配置好了，尽管我们还没自己的后端（还！）。让我们从一个简单的C程序开始： #include &amp;lt;stdio.h&amp;gt; int main(void) { printf(&quot;Hello world!\n&quot;); return 0; } 首先，使用Clang将C代码编译为LLVM IR。 我们的计划是使用标准库中来自头文件stdio.h的函数printf，如果不能找到头文件，编译器会提示出错。 为了使用GCC自带的RISC V标准C库，我们使用了-isystem参数。 这会将包含所需头文件的目录添加到Clang预处理器的搜索目录列表中。 clang -O2 -emit-llvm -target riscv64 -isystem &amp;lt;PATH_TO_GCC&amp;gt;/riscv64-unknown-elf/include -c test.c -o test.bc 上面的命令把C语言文件test.c编译到LLVM IR文件test.bc，这是专门为机器设计的语言人类很难直接阅读。 我们可以使用以下命令反汇编该文件： llvm-dis test.bc 现在，使用包含以下内容的后端将IR编译为程序集，而无需使用以下命令下载LLVM： 现在，使用LLVM自带的后端将IR编译为程汇编： llc -march=riscv64 -O2 -filetype=asm test.bc -o test.S GCC可以直接生成程序的二进制文件。 我将其分为两个步骤，但是您可以根据需要使用单个命令。 riscv64-unknown-elf-gcc -c test.S -o test.o riscv64-unknown-elf-gcc test.o -o test 最后，我们可以使用模拟器或真实硬件运行程序。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">为LLVM添加简易RISCV后端(一)：简介</title><link href="http://localhost:4000/blog/RISCW-1.html" rel="alternate" type="text/html" title="为LLVM添加简易RISCV后端(一)：简介" /><published>2020-12-03T19:30:38+08:00</published><updated>2020-12-03T19:30:38+08:00</updated><id>http://localhost:4000/blog/RISCW-1</id><content type="html" xml:base="http://localhost:4000/blog/RISCW-1.html">&lt;p&gt;为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;在本教程中，我将为RISC V指令集的基本32位版本（即RV32IM）开发一个后端。希望这能帮助那些不熟悉LLVM的人开始使用这个工具，并将其扩展到自己的项目中。看懂本教程不需要前置知识，但是如果你熟悉C++和RISC V，学习本教程会更容易。&lt;/p&gt;

&lt;p&gt;在本文剩下的部分中，我将简要描述LLVM的体系结构和后端结构。不过，我不会在这里详细说明，因为，如果你像我一样，在5分钟（或5秒）之后，就会忘记读过的任何繁琐文档。LLVM的细节将在以后的帖子中根据需要提供。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;如果你想要更详细的版本，你可以自娱自乐地阅读&lt;a href=&quot;http://llvm.org/docs/UserGuides.html&quot;&gt;LLVM User Guides&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;llvm架构&quot;&gt;LLVM架构&lt;/h3&gt;

&lt;p&gt;传统上，编译过程分为三个阶段。
首先，编译器的前端将源代码转换为某种中间表示（IR）；
然后，优化IR；
最后，编译器的后端将IR转换为机器代码。
传统的编译器通常仅支持一种编程语言和一种目标指令集，编译器的源代码很难重用，例如添加新的目标指令集。&lt;/p&gt;

&lt;p&gt;LLVM模块化地实现了三个编译过程，可以解决重用问题。
其思想是LLVM的核心（即IR和优化器）是固定的，但是前端和后端可以被替换，以使编译器可以支持多种编程语言和指令集。
例如，我们可以使用Clang（LLVM的前端）和x86后端把C/C++代码编译成X86指令集上的可执行程序。
我们也可以用ARM后端替换X86后端，从而得到ARM指令集上的可执行程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;LLVM的设计师Chris Lattner撰写了这篇&lt;a href=&quot;http://www.aosabook.org/en/llvm.html&quot;&gt;文章&lt;/a&gt;介绍LLVM的体系结构及其设计动机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;LLVM的这三个阶段的每个阶段在都有一个专用的可执行文件。
clang是C/C++的前端（显然针对不同的编程语言有不同的前端），opt是优化程序，llc用于调用后端。
通常，我们使用clang作为驱动程序来执行前端，使用llc和opt配合适当的参数来生成IR，汇编，可执行文件等。&lt;/p&gt;

&lt;h3 id=&quot;代码生成&quot;&gt;代码生成&lt;/h3&gt;
&lt;p&gt;LLVM后端将IR编译为目标代码或汇编代码。
每个后端都只支持单一平台，但可以支持多个指令集。
例如，LLVM只有一个ARM后端，但该后端可以为ARMv6和ARMv7等指令集生成代码。
每个后端都建立在LLVM的目标无关代码生成器之上。
目标无关代码生成器是一个框架，可实现诸如寄存器分配之类的关键算法。
从广义上讲，后端的任务是配置该框架并使之适应其目标指令集的特定需求。&lt;/p&gt;

&lt;p&gt;代码生成具有以下阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;指令选择&lt;/strong&gt; 映射LLVM IR到目标指令集中的指令。
此阶段使用无限数量的虚拟寄存器和函数调用堆栈的抽象引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;计划和编排&lt;/strong&gt; 确定指令的顺序。
需要明确的是，在指令选择阶段已经对指令进行了排序，但这里可以根据寄存器分配策略或指令等待时间来对其中的一些指令的排序进行优化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;基于SSA的机器代码优化&lt;/strong&gt; 执行诸如&lt;a href=&quot;https://en.wikipedia.org/wiki/Peephole_optimization&quot;&gt;peephole&lt;/a&gt;优化之类的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;寄存器分配&lt;/strong&gt; 将虚拟寄存器映射到物理寄存器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Prolog / Epilog插入&lt;/strong&gt; 在每个函数的开头（或prolog）和结尾（或epilog）插入机器指令。
这些通常是在进入或退出函数时扩展堆栈的指令。
由于当前已经知道堆栈大小，因此也可以解析抽象堆栈引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;后期机器代码优化&lt;/strong&gt; 可能不言自明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;代码发射&lt;/strong&gt; 发出目标代码或汇编代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，我将看一下构建LLVM以及如何设置开发/调试环境…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可以阅读&lt;a href=&quot;http://llvm.org/docs/CodeGenerator.html&quot;&gt;这篇文章&lt;/a&gt;了解LLVM目标无关代码生成器的更多信息。&lt;/p&gt;

&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://jonathan2251.github.io/lbd/&quot;&gt;这个教程&lt;/a&gt;描述了如何开发LLVM后端，但我发现很难理解。 &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="LLVM" /><summary type="html">为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！ 一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程12。 因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。 简介 在本教程中，我将为RISC V指令集的基本32位版本（即RV32IM）开发一个后端。希望这能帮助那些不熟悉LLVM的人开始使用这个工具，并将其扩展到自己的项目中。看懂本教程不需要前置知识，但是如果你熟悉C++和RISC V，学习本教程会更容易。 在本文剩下的部分中，我将简要描述LLVM的体系结构和后端结构。不过，我不会在这里详细说明，因为，如果你像我一样，在5分钟（或5秒）之后，就会忘记读过的任何繁琐文档。LLVM的细节将在以后的帖子中根据需要提供。 注意:如果你想要更详细的版本，你可以自娱自乐地阅读LLVM User Guides。 LLVM架构 传统上，编译过程分为三个阶段。 首先，编译器的前端将源代码转换为某种中间表示（IR）； 然后，优化IR； 最后，编译器的后端将IR转换为机器代码。 传统的编译器通常仅支持一种编程语言和一种目标指令集，编译器的源代码很难重用，例如添加新的目标指令集。 LLVM模块化地实现了三个编译过程，可以解决重用问题。 其思想是LLVM的核心（即IR和优化器）是固定的，但是前端和后端可以被替换，以使编译器可以支持多种编程语言和指令集。 例如，我们可以使用Clang（LLVM的前端）和x86后端把C/C++代码编译成X86指令集上的可执行程序。 我们也可以用ARM后端替换X86后端，从而得到ARM指令集上的可执行程序。 注意：LLVM的设计师Chris Lattner撰写了这篇文章介绍LLVM的体系结构及其设计动机。 注意：LLVM的这三个阶段的每个阶段在都有一个专用的可执行文件。 clang是C/C++的前端（显然针对不同的编程语言有不同的前端），opt是优化程序，llc用于调用后端。 通常，我们使用clang作为驱动程序来执行前端，使用llc和opt配合适当的参数来生成IR，汇编，可执行文件等。 代码生成 LLVM后端将IR编译为目标代码或汇编代码。 每个后端都只支持单一平台，但可以支持多个指令集。 例如，LLVM只有一个ARM后端，但该后端可以为ARMv6和ARMv7等指令集生成代码。 每个后端都建立在LLVM的目标无关代码生成器之上。 目标无关代码生成器是一个框架，可实现诸如寄存器分配之类的关键算法。 从广义上讲，后端的任务是配置该框架并使之适应其目标指令集的特定需求。 代码生成具有以下阶段： 指令选择 映射LLVM IR到目标指令集中的指令。 此阶段使用无限数量的虚拟寄存器和函数调用堆栈的抽象引用。 计划和编排 确定指令的顺序。 需要明确的是，在指令选择阶段已经对指令进行了排序，但这里可以根据寄存器分配策略或指令等待时间来对其中的一些指令的排序进行优化。 基于SSA的机器代码优化 执行诸如peephole优化之类的工作。 寄存器分配 将虚拟寄存器映射到物理寄存器。 Prolog / Epilog插入 在每个函数的开头（或prolog）和结尾（或epilog）插入机器指令。 这些通常是在进入或退出函数时扩展堆栈的指令。 由于当前已经知道堆栈大小，因此也可以解析抽象堆栈引用。 后期机器代码优化 可能不言自明。 代码发射 发出目标代码或汇编代码。 接下来，我将看一下构建LLVM以及如何设置开发/调试环境… 注意：您可以阅读这篇文章了解LLVM目标无关代码生成器的更多信息。 注释 公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。 &amp;#8617; 这个教程描述了如何开发LLVM后端，但我发现很难理解。 &amp;#8617;</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/blog/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2020-12-03T18:38:38+08:00</published><updated>2020-12-03T18:38:38+08:00</updated><id>http://localhost:4000/blog/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/blog/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;Jekyll requires blog post files to be named according to the following format:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR&lt;/code&gt; is a four-digit number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MONTH&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DAY&lt;/code&gt; are both two-digit numbers, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MARKUP&lt;/code&gt; is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated. Jekyll requires blog post files to be named according to the following format: YEAR-MONTH-DAY-title.MARKUP Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works. Jekyll also offers powerful support for code snippets: def print_hi(name) puts &quot;Hi, #{name}&quot; end print_hi('Tom') #=&amp;gt; prints 'Hi, Tom' to STDOUT. Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.</summary></entry></feed>