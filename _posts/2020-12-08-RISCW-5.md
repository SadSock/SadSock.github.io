---
layout: post
title: "为LLVM添加简易RISCV后端(五)：指令选择"
toc: true
date: 2020-12-08 19:30:38 +0800
categories: LLVM
keywords: LLVM
description: 无
---

为一个新的指令集编写编译器是一件复杂的事情，尽管LLVM的出现使这个过程比之前简单多了！
一个匪夷所思的困难是缺乏一个简单的、循序渐进的教程[^1][^2]。
因此，本系列博客试图提供一个从头开始编写LLVM后端的简易教程来解决（部分）问题。


## 指令选择

我们先前简要介绍了LLVM后端的工作过程。
在这篇文章中，我们将更深入地了解这个过程的第一个阶段：指令选择。
我们的目的是在了解RISCW后端的具体实现之前，了解它的工作原理以及如何配置它。

**注意：**[LLVM文档](https://llvm.org/docs/CodeGenerator.html#instruction-selection-section)对指令选择的工作原理给出了简短而清晰的描述，
这篇文章通过示例来重新说明这一点。

**注意：**本文中显示的示例是使用我们的RISCW后端框架构建的。可以在[这里](https://github.com/andresag01/llvm-project/commit/274cfea0f9662f0ed49f6132b0424323d0b11750)找到它的来源。


指令选择过程将LLVM IR转化为指令序列，该指令序列使用了无穷数量的寄存器。
该过程分为以下几个阶段：
1. 构建初始DAG
2. 优化
3. 类型合法化
4. 优化
5. 操作合法化
6. 优化
7. 目标指令选择
8. 调度和形成

我觉得通过例子来了解发生的事情会比较容易，我们将考虑指令选择如何转换下面的C程序。
该代码包含一个MUL函数，该函数接受64位参数x和32位参数y。
参数相乘，并返回32位整数结果。

```C++
unsigned int MUL(unsigned long long int x, unsigned int y)
{
    return x * y;
}

```

### 构建DAG

这是指令选择的第一阶段。
它接受LLVM IR作为输入，
并产生Selection DAG(有向无环图)作为输出。
指令选择过程中的每个其他阶段都在DAG上执行，直到产生输出指令序列。
正如前面几篇文章所讨论的，LLVM IR是前端工具(如Clang)根据C代码生成，随后由LLVM优化器进行优化。
下面是C程序的LLVM IR:
```llvm
define dso_local i32 @MUL(i64 %x, i32 %y) local_unnamed_addr #0 {
entry:
  %0 = trunc i64 %x to i32
  %conv1 = mul i32 %0, %y
  ret i32 %conv1
}
```
Selection DAG实际上是一种精巧的树型数据结构，它表示LLVM IR中的基本块。 
基本块是不包含分支目的地（入口除外）和分支指令（出口除外）的指令序列。 
示例MUL函数非常简单，它只有一个称为入口的基本块，其他函数通常具有多个基本块。 
例如，下面的`hello`函数具有四个基本块：`entry`，`if.then`，`if.else`和`return`。
每个基本块都将被转换为单独的DAG。
```llvm
define dso_local i32 @hello(i32 %x) local_unnamed_addr #0 {
entry:
  %cmp = icmp eq i32 %x, 100
  br i1 %cmp, label %if.then, label %if.else
    
if.then:                                          ; preds = %entry
  %call = tail call i32 bitcast (i32 (...)* @hello100 to i32 (i32)*)(i32 100) #2
  br label %return
        
        if.else:                                          ; preds = %entry
          %call1 = tail call i32 bitcast (i32 (...)* @helloOther to i32 (i32)*)(i32 %x) #2
            br label %return
            
            return:                                           ; preds = %if.else, %if.then
              %retval.0 = phi i32 [ %call, %if.then ], [ %call1, %if.else ]
                ret i32 %retval.0
                }
}
```






## 注释

[^1]:公平地说，有不少关于LLVM的书籍和网站，但大多数都是对这个工具的一般性描述，还有是关于如何编写新前端的实践教程，但后端的教程非常少。
[^2]:[这个教程](https://jonathan2251.github.io/lbd/)描述了如何开发LLVM后端，但我发现很难理解。
